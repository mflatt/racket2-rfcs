#lang rhombus/static/and_meta
import:
  rhombus/thread open
  rhombus/system
  lib("racket/base.rkt") as rkt
  "private/shell.rkt" as rkt_shell
  lib("racket/private/streams.rkt") as rkt_stream

export:
  run
  shell
  run_shell
  run_command
  Subprocess
  current_subprocess_group_new
  current_subprocess_custodian_mode

def current_subprocess_group_new:
  rkt.#{make-derived-parameter}(rkt.#{subprocess-group-enabled},
                                values,
                                values,
                                #'current_subprocess_group_enabled,
                                #'rhombus)

def current_subprocess_custodian_mode:
  rkt.#{make-derived-parameter}(rkt.#{current-subprocess-custodian-mode},
                                values,
                                values,
                                #'current_subprocess_custodian_mode,
                                #'rhombus)

fun current_group():
  if current_subprocess_group_new()
  | #'new
  | #'same

class Subprocess(hand, output, input, error_output, desc, is_new):
  // output, input, and error_output can be a port, thread, or #false
  opaque
  internal _Subprocess
  implements Closeable
  // like `run`, but different defaults:
  constructor (exe :: PathString,
               ~in: in :: Port.Input || Subprocess.Pipe = #'pipe,
               ~out: out :: Port.Output || Subprocess.Pipe = #'pipe,
               ~err: err :: Port.Output || Subprocess.ErrorPipe = #'pipe,
               ~group: group :: Subprocess.Group || Subprocess.NewGroup = current_group(),
               arg :: PathString || ReadableString, ...):
    do_run(to_string(exe), exe, arg, ..., ~in: in, ~out: out, ~err: err, ~group: group)
  private implements Printable
  private override method describe(mode, recur):
    PrintDesc.concat("Subprocess(", repr(to_string(desc)), ")")
  property handle: hand
  property maybe_to_in :~ maybe(Port.Output): input is_a Port.Output && input
  property maybe_from_out :~ maybe(Port.Input): output is_a Port.Input && output
  property maybe_from_err :~ maybe(Port.Input): error_output is_a Port.Input && error_output
  fun not_available(who): error(~who: who, "pipe not available")
  property to_in :~ Port.Output: maybe_to_in || not_available(#'to_in)
  property from_out :~ Port.Input: maybe_from_out || not_available(#'from_out)
  property from_err :~ Port.Input: maybe_from_err || not_available(#'from_err)
  property pid: rkt.#{subprocess-pid}(hand)
  override method close():
    when input is_a Port.Output | Port.Output.close(input)
    when output is_a Port.Input | Port.Input.close(output)
    when error_output is_a Port.Input | Port.Input.close(error_output)
  method wait():
    rkt.#{sync}(hand)
    when input is_a Thread | Thread.wait(input)
    when output is_a Thread | Thread.wait(output)
    when error_output is_a Thread | Thread.wait(error_output)
    rkt.#{subprocess-status}(hand)
  method wait_ok():
    wait() == 0
  method poll():
    if rkt.#{subprocess-status}(hand) == #'running
    | #false
    | wait()
  method interrupt():
    rkt.#{subprocess-kill}(hand)
  method kill():
    rkt.#{subprocess-kill}(hand, #true)

  export:
    Pipe
    ErrorPipe
    NewGroup
    Group

  enum Pipe:
    pipe
  enum ErrorPipe:
    ~is_a Pipe
    out

  annot.macro 'NewGroup':
    'satisfying(fun (p): p is_a Subprocess && _Subprocess.is_new(p))'

  enum Group:
    same
    new
    ~is_a NewGroup
  
fun do_run(desc :: String,
           exe :: PathString,
           ~in: in :: Port.Input || Subprocess.Pipe = Port.Input.current(),
           ~out: out :: Port.Output || Subprocess.Pipe = Port.Output.current(),
           ~err: err :: Port.Output || Subprocess.ErrorPipe = Port.Output.current_error(),
           ~group: group :: Subprocess.Group || Subprocess.NewGroup = current_group(),
           arg, ...) :~ Subprocess:
  let (handle, o, i, e): rkt.subprocess(out != #'pipe && rkt_stream.#{if-stream-out}(#false, out),
                                        in != #'pipe && rkt_stream.#{if-stream-in}(#false, in),
                                        if err == #'out
                                        | #'stdout
                                        | err != #'pipe && rkt_stream.#{if-stream-out}(#false, err),
                                        match group
                                        | #'same: #false
                                        | #'new: #'new
                                        | p :: Subprocess: p.hand,
                                        exe, arg, ...)
  let break_ok = Semaphore(0)
  fun wrap(p): if rkt.#{thread?}(p) | Thread.from_handle(p) | p
  let i = wrap(rkt_stream.#{streamify-in}(in != #'pipe && in, i,
                                          fun (on): if on
                                                    | break_ok.post()
                                                    | break_ok.wait()))
  let o = wrap(rkt_stream.#{streamify-out}(out != #'pipe && out, o))
  let e = wrap(rkt_stream.#{streamify-out}(err != #'pipe && err != #'out && err, e))
  let sp = _Subprocess(handle, o, i, e, desc, group == #'new)
  when i is_a Thread
  | // Wait for process to end, then stop copying input:
    thread:
      rkt.sync(handle)
      break_ok.wait()
      Thread.break(i)
  sp

fun run(exe :: PathString,
        ~in: in :: Port.Input || Subprocess.Pipe = Port.Input.current(),
        ~out: out :: Port.Output || Subprocess.Pipe = Port.Output.current(),
        ~err: err :: Port.Output || Subprocess.ErrorPipe = Port.Output.current_error(),
        ~group: group :: Subprocess.Group || Subprocess.NewGroup = current_group(),
        arg :: PathString || ReadableString, ...) :~ Subprocess:
  do_run(to_string(exe), exe, arg, ..., ~in: in, ~out: out, ~err: err, ~group: group)

fun run_shell(command :: String,
              ~in: in :: Port.Input || Subprocess.Pipe = Port.Input.current(),
              ~out: out :: Port.Output || Subprocess.Pipe = Port.Output.current(),
              ~err: err :: Port.Output || Subprocess.ErrorPipe = Port.Output.current_error(),
              ~group: group :: Subprocess.Group || Subprocess.NewGroup = current_group()) :~ Subprocess:
  let args = rkt_shell.#{shell-path/args}(#'#{subprocess.shell}, command)
  do_run(command, & args, ~in: in, ~out: out, ~err: err, ~group: group)

fun shell(command :: String,
          ~group: group :: Subprocess.Group = #'same):
  let args = rkt_shell.#{shell-path/args}(#'#{subprocess.shell}, command)
  let sp = do_run(command, & args, ~group: group)
  sp.wait_ok()

fun run_command(exe :: PathString,
                command :: String,
                ~in: in :: Port.Input || Subprocess.Pipe = Port.Input.current(),
                ~out: out :: Port.Output || Subprocess.Pipe = Port.Output.current(),
                ~err: err :: Port.Output || Subprocess.ErrorPipe = Port.Output.current_error(),
                ~group: group :: Subprocess.Group || Subprocess.NewGroup = current_group(),
                arg :: PathString || ReadableString, ...) :~ Subprocess:
  unless system.type() == #'windows
  | error(~who: #'run_command, "supported only on Windows")
  do_run(command, exe, #'exact, command, ~in: in, ~out: out, ~err: err, ~group: group)
