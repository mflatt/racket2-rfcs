#lang rhombus

import:
  lib("racket/base.rkt") as rkt
  lib("rhombus/private/treelist.rhm").TreeList
  lib("rhombus/private/treelist.rkt") open
  rhombus/measure

// Turn off all but one to get a useful (thoough rough) performance result:
def do_list = #true
def do_TreeList = #false
def do_treelist = #true

// rkt.#{random-seed}(10)

fun insert(lst, pos, v):
  cond
  | pos == 0: List.cons(v, lst)
  | lst == []: [v]
  | ~else List.cons(List.first(lst), insert(List.rest(lst), pos-1, v))

fun rand_test(lst, tl, rtl, n, history):
  // println([n, history, rtl])
  fun check():
    when do_list && do_TreeList
    | unless lst == tl.to_list()
      | error(#'rand_test, "fail " +& lst +& " vs. " +& tl +& " using " +& List.reverse(history))
    when do_list && do_treelist
    | unless lst == #{treelist->list}(rtl)
      | error(#'rand_test, "fail " +& lst +& " vs. " +& rtl +& " using " +& List.reverse(history))
    when do_treelist
    | let rtl2 = #{list->treelist}(#{treelist->list}(rtl))
      unless (rtl2 == rtl) && (rtl == rtl2) && Equatable.hash(rtl) == Equatable.hash(rtl2)
      | error(#'rand_test, "equal fails " +& rtl)
  cond
  | n >= 1000:
      check()
  | ~else:
      when (n mod 100) == 0
      | check()  
      let pos = rkt.random(n+2)
      if pos == n+1
      | rand_test(do_list && (lst ++ lst),
                  do_TreeList && (tl ++ tl),
                  do_treelist && #{treelist-append}(rtl, rtl),
                  2 * n,
                  List.cons(#'append, history))
      | rand_test(do_list && insert(lst, pos, n),
                  do_TreeList && TreeList.insert(tl, pos, n),
                  do_treelist && #{treelist-insert}(rtl, pos, n),
                  n + 1,
                  List.cons(pos, history))

measure.time:
  for (i: 0..1000):
    rand_test([], TreeList[], #{make-treelist}(), 0, [])
