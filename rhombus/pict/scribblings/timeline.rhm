#lang rhombus/static

import:
  pict open
  draw
  scribble/rhombus.centered
  scribble/rhombus/manual:
    expose:
      make_rhombus_eval
      examples

export:
  pict_eval
  timeline
  stretched_timeline

def pict_eval = make_rhombus_eval()

block:
  @examples(
    ~eval: pict_eval
    ~hidden:
      import:
        pict open
        draw
  )
  #void

fun time_at(t) :~ Pict:
  beside(~vert: #'baseline,
         text("t", ~font: draw.Font(~style: #'italic)),
         text(" = " +& t))

def epoch_dot_size = 10
def epoch_dot_color = "red"
def duration_box_color = "pink"
def duration_box_pad = 4

fun tl_arrows(p :~ Pict, dot :~ Pict):
  let q = p.pad(~horiz: 24)
  let (_, dy) = Find.left(dot).in(p)
  let dy = dy - (q.height / 2)
  let q = connect(q, Find.left(p, ~dy: dy), Find.left(q, ~dy: dy), ~style: #'arrow, ~arrow_size: 8)
  let q = connect(q, Find.right(p, ~dy: dy), Find.right(q, ~dy: dy), ~style: #'arrow, ~arrow_size: 8)
  q  

fun stackx(a, b :~ Pict) :~ Pict:
  let p = stack(a, b)
  p.pad(~horiz: (b.width - p.width) / 2)
                
fun timeline(p_in :~ Pict, [t, ...],
             ~pre: pre = 0,
             ~post: post = 0,
             ~label: label = #false,
             ~balance_label = #false):
  let sep = 20
  fun p_at_time(t, keep): if keep
                          | p_in.snapshot(math.exact(math.floor(t)),
                                          t - math.floor(t))
                          | nothing
  let w = p_in.width
  let dot = circle(~size: epoch_dot_size, ~fill: epoch_dot_color)
  fun mk_dot(_): dot.launder()
  fun epochly(p :~ Pict, t):
    if t == math.floor(t)
    | p
    | overlay(p.ghost(), line(~dx: p.width))
  let [t_dot, ...]: [mk_dot(t), ...]
  let [lt_dot, ...]: [stackx(time_at(t), epochly(t_dot, t)), ...]
  let p :~ Pict:
    let sep = sep + w - dot.width
    fun keep(p, keep): if keep | p | nothing  
    let tb = beside(~sep: sep, keep(lt_dot, t >= 0 && t < p_in.duration), ...)
    beside(~sep: sep, beside(~sep: sep, keep(lt_dot, t < 0), ...),
           overlay(~vert: #'bottom,
                   rectangle(~width: tb.width + sep, ~height: dot.height + 2*duration_box_pad,
                             ~line: duration_box_color).pad(~bottom: -4, ~left: sep/2 + 4).translate(sep/4-1, 0),
                   tb)
             .refocus(tb),
           beside(~sep: sep, keep(lt_dot, t >= p_in.duration), ...))
  let p = tl_arrows(p, [t_dot, ...].first)
  let (p, _):
    for values(p = p, prev = #false) (t_dot: [t_dot, ...]):
      values(if prev
             | connect(p, Find.right(prev), Find.left(t_dot))
             | p,
             t_dot)
  let imgs:
    let tb = beside(~sep: sep, p_at_time(t, t >= 0 && t < p_in.duration), ...)
    beside(~sep: sep,
           beside(~sep: sep, p_at_time(t, t < 0), ...),
           tb,
           beside(~sep: sep, p_at_time(t, t >= p_in.duration), ...))
  let p:
    stack(~sep: 10, p, imgs).pad(~horiz: 10)
  let p = p.pad(~left: pre * (w + sep), ~right: post * (w + sep))
  let p:
    if label
    | let label = text(label, ~font: draw.Font(~kind: #'modern))
      beside(~sep: 20, label, p, if balance_label | label.ghost() | nothing)
    | p
  centered(p)

def stretched_timeline:
  let d1 = rectangle(~width: epoch_dot_size * 5,
                     ~height: epoch_dot_size,
                     ~rounded: epoch_dot_size/2,
                     ~fill: epoch_dot_color)
  let d2 = rectangle(~width: epoch_dot_size * 3,
                     ~height: epoch_dot_size,
                     ~rounded: epoch_dot_size/2,
                     ~fill: epoch_dot_color)
  let d3 = rectangle(~width: epoch_dot_size * 4,
                     ~height: epoch_dot_size,
                     ~rounded: epoch_dot_size/2,
                     ~fill: epoch_dot_color)
  let d4 = circle(~size: epoch_dot_size,
                  ~fill: epoch_dot_color)
  let p:
    beside(stackx(time_at(0), d1),
           blank(~width: epoch_dot_size * 4),
           stackx(time_at(1), d2),
           blank(~width: epoch_dot_size * 8),
           stackx(time_at(2), d3),
           blank(~width: epoch_dot_size * 4),
           stackx(time_at(3).ghost(), d4)).pad(~bottom: 8)
  fun pointy(p):
    let pt = blank()
    let q = stack(~sep: 10, pt, p)
    let q = connect(q, Find.bottom(pt), Find.top(p))
    q.refocus(pt)
  let p = connect(p, Find.right(d1), Find.left(d2),
                  ~label: pointy(time_at(0.5)))
  let p = connect(p, Find.right(d2), Find.left(d3),
                  ~label: pointy(time_at(1.5)))
  let p = connect(p, Find.right(d3), Find.left(d4),
                  ~label: pointy(time_at(2.5)))
  let p :~ Pict:
    let (sx, sy) = Find.left(d1).in(p)
    let (ex, _) = Find.left(d4).in(p)
    pin(~on: p,
        ~at: Find.abs(sx, sy - epoch_dot_size/2 - duration_box_pad),
        ~order: #'back,
        rectangle(~width: ex-sx, ~height: epoch_dot_size + 2*duration_box_pad,
                  ~line: duration_box_color))
  fun elapsed(p, d1, d2, label):
    let (sx, sy) = Find.right(d1).in(p)
    let (ex, _) = Find.left(d2).in(p)
    let b = text("{", ~font: draw.Font(~kind: #'roman)).rotate(math.pi * -1/2)
    let b = b.scale((ex - sx) / b.width, 1)
    let b = stack(text(label), b)
    pin(~on: p,
        ~at: Find.abs(sx, 0),
        b)
  let p: p.pad(~top: 12)
  let p: elapsed(p, d1, d2, "0.5 sec")
  let p: elapsed(p, d2, d3, "1.0 sec")
  let p: elapsed(p, d3, d4, "0.5 sec")
  stack(tl_arrows(p, d1), time_at(2.5).ghost())
