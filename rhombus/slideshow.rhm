#lang rhombus/static/and_meta

import:
  draw
  pict:
    expose Pict
  pict/text
  rhombus/pict/text!ly.ly
  slideshow/config
  lib("slideshow/main.rkt") as rkt
  lib("pict/main.rkt") as rkt_pict
  lib("slideshow/play.rkt") as rkt_play
  lib("racket/string.rkt")  

export:
  all_from(.pict)
  all_from(.text)

  current_title_font
  titlet
  titlely

  SlideLayout
  current_assembler

  // flattens nested lists in arguments:
  slide
  slide_content

  interactive

  is_printing
  is_condensing

  start_at_recent
  retract_recent

namespace slide:
  export:
    next
    gap
    alts

    align

    right
    center
    left
    horiz

// ----------------------------------------

Parameter.def current_title_font :: draw.Font:
  text.current_font() with (size = 40)

ly titlely: current_title_font()

fun titlet(a, ...) :~ Pict:
  titlely(a, ...)

// ----------------------------------------

class Next():
  implements Printable
  override describe(mode, recur):
    "slide.next"
def next = Next()

class Alts(alts :~ List.of(List)):
  implements Printable
  override describe(mode, recur):
    PrintDesc.list("slide.alts(", alts.map(recur), ")")

fun alts(contents, ...):
  Alts([flatten_slide_content(#'alts, contents),
        ...])

class Align(sep, horiz, cs :: List, width)
class Horiz(sep, horiz, cs :: List)

fun horiz(~sep: sep :: Real || matching(#'inherit) = #'inherit,
          ~horiz: horiz :: pict.HorizAlignment = #'left,
          content, ...):
  Horiz(sep, horiz, flatten_slide_content(#'horiz, [content, ...]))

fun left(~sep: sep :: Real || matching(#'inherit) = #'inherit,
         content, ...):
  Horiz(sep, #'left, flatten_slide_content(#'left, [content, ...]))

fun center(~sep: sep :: Real || matching(#'inherit) = #'inherit,
           content, ...):
  Horiz(sep, #'center, flatten_slide_content(#'center, [content, ...]))

fun right(~sep: sep :: Real || matching(#'inherit) = #'inherit,
          content, ...):
  Horiz(sep, #'right, flatten_slide_content(#'right, [content, ...]))

def gap = 24

fun align(~sep: sep :: Real || matching(#'inherit) = #'inherit,
          ~horiz: horiz :: pict.HorizAlignment = #'left,
          content, ...):
  Align(sep, horiz, flatten_slide_content(#'right, [content, ...]), #false)

fun flatten_slide_content(who, c) :~ List:
  match c
  | [c, ...]: List.append(flatten_slide_content(who, c), ...)
  | p :: pict.NothingPict: []
  | p :: Pict: [p]
  | p :: Next: [p]
  | Alts([]): []
  | Alts([alt]): alt
  | p :: Alts: [p]
  | p :: Horiz: [p]
  | p :: Align: [p]
  | ~else:
      error(who, "bad slide content: " +& to_string(c, ~mode: #'expr))

// generated in `align_content` for consumption by `next_to_anim`:
class SetSep(sep)

fun next_to_anim(contents) :~ Pict:
  recur loop (sep = gap, contents = contents, accum :~ List = []) :~ Pict:
    match contents
    | []:
        pict.stack(~sep: sep, & accum)
    | [p :: Next, & contents]:
        let pre = pict.stack(~sep: sep, & accum)
        let post = loop(sep, contents, [])
        pict.stack(~sep: sep,
                   pre.sustain(post.duration),
                   post.time_pad(~before: pre.duration))
    | [Alts([alt, ...]), & contents]:
        let none = []
        let alts = [loop(sep, alt, none), ...]
        let p = pict.overlay(~vert: #'top,
                             ~duration: #'pad,
                             & pict.sequential(& alts))
        let pre = pict.stack(~sep: sep, & accum)
        loop(sep, contents, [pre, p])
    | [SetSep(sep), & contents]:
        loop(sep, contents, accum)
    | [c, & contents]:
        loop(sep, contents, accum.add(c))

annot.macro 'SlideLayout': 'matching(#'auto || #'center || #'top || #'tall)'

fun slide(~title: title :: maybe(String || Pict) = #false,
          ~name: name = title,
          ~layout: layout :: SlideLayout = #'auto,
          ~sep: sep :: Real = gap,
          ~horiz: horiz :: pict.HorizAlignment = #'center,
          ~lead_in: lead_in = #false,
          content, ...):
  let p = next_to_anim(align_content(sep, horiz, flatten_slide_content(#'slide, [content, ...])))
  let name = if name is_a String | name | to_string(name)
  let p: assemble_slide(title, layout, p)
  when lead_in
  | rkt_play.#{play-n}(~name: name,
                       #{#:skip-first?}: #true,
                       #{#:skip-last?}: #true,
                       fun (n): p.snapshot(-1, n).handle)
  for (i: 0..p.duration):
    let extent = p.epoch_extent(i)
    if extent .= 0
    | rkt.slide(~name: name,
                & (if p == pict.nothing
                   | []
                   | [p.snapshot(i, 0).handle]))
    | rkt_play.#{play-n}(~name: name,
                         ~delay: extent / rkt_play.#{current-play-steps}(),
                         #{#:skip-last?}: #true,
                         fun (n): p.snapshot(i, n).handle)

fun slide_content(~title: title :: maybe(String || Pict) = #false,
                  ~full: full = title && #true,
                  ~sep: sep :: Real = gap,
                  ~horiz: horiz :: pict.HorizAlignment = #'center,
                  ~layout: layout :: SlideLayout = #'auto,
                  content, ...) :~ Pict:
  let p = next_to_anim(align_content(sep, horiz, flatten_slide_content(#'slide_content, [content, ...])))
  if full
  | assemble_slide(title, layout, p)
  | p

fun assemble_slide(title, layout, p) :~ Pict:  
  match title
  | _ :: pict.NothingPict:
      current_assembler()(#false, layout, p)
  | _ :: String:
      current_assembler()(titlet(title), layout, p)
  | ~else:
      current_assembler()(title, layout, p)

Parameter.def current_assembler :: Function.of_arity(3):
  fun (title :: False || Pict, layout:: SlideLayout, p :: Pict):
    recur retry(title = title, p :~ Pict = p):
      cond
      | layout == #'auto && !(p is_a pict.StaticPict):
          // layout decision depends on size, so use size
          // at each step, instead of only the starting size
          if title
          | pict.animate_map([title, p], ~combine: fun ([title, p]): retry(title, p))
          | pict.animate_map([p], ~combine: fun ([p]): retry(title, p))
      | ~else:
          let back: Pict.from_handle(rkt.#{get-full-page}())
          let head :~ Pict:
            if title
            | Pict.pad(title, ~bottom: if layout == #'tall | gap | 2*gap)
            | pict.blank()
          let layout:
            match layout
            | #'auto:
                if p.height > (back.height - 2 * head.height) | #'top | #'center
            | ~else: layout
          let body:
            match layout
            | #'center: back
            | ~else: back.pad(~top: -head.height)
          pict.overlay(~vert: #'bottom,
                       pict.overlay(~vert: #'top,
                                    back,
                                    head),
                       pict.overlay(~vert: match layout
                                           | #'tall: #'top
                                           | ~else: layout,
                                    body,
                                    p)
                         .refocus(body))
            .refocus(back)
                        
// ----------------------------------------

fun align_content(sep, horiz, contents):
  let [width, recorded :~ List]:
    recur gather_widths (cs :: List = contents):
      let (max_w, accum):
        for values(max_w = 0, accum :~ List = []) (c: cs):
          match c
          | p :: Pict: values(math.max(max_w, p.width),
                              accum.add(p))
          | next :: Next: values(max_w, accum.add(next))
          | Alts([alt, ...]):
              let [[w, alt], ...]:
                [gather_widths(alt), ...]
              values(math.max(max_w, w, ...),
                     accum.add(Alts([alt, ...])))
          | Horiz(sep, horiz, cs):
              let [w, recorded] = gather_widths(cs)
              values(math.max(max_w, w),
                     accum.add(Horiz(sep, horiz, recorded)))
          | Align(sep, horiz, cs, _):
              let [w, recorded] = gather_widths(cs)
              values(math.max(max_w, w),
                     accum.add(Align(sep, horiz, recorded, w)))
      [max_w, accum]
  recur widen (w = width, sep = sep, horiz = horiz, cs :: List = recorded):
    List.append(
      & for List (c: cs):
        match c
        | p :: Pict:
            [match horiz
             | #'left: p.pad(~right: width - p.width)
             | #'center: p.pad(~horiz: (width - p.width) / 2)
             | #'right: p.pad(~left: width - p.width)]
        | next :: Next: [next]
        | Alts([alt, ...]):
            [Alts([widen(w, sep, horiz, alt), ...])]
        | Horiz(h_sep, horiz, cs):
            let mid = widen(w, if h_sep == #'inherit | sep | h_sep, horiz, cs)
            if h_sep == #'inherit
            | mid
            | [SetSep(h_sep)] ++ mid ++ [SetSep(sep)]
        | Align(align_sep, horiz, cs, w):
            let mid = widen(w, if align_sep == #'inherit | sep | align_sep, horiz, cs)
            if align_sep == #'inherit
            | mid            
            | [SetSep(align_sep)] ++ mid ++ [SetSep(sep)]
    )

// ----------------------------------------

fun interactive(p :: Pict, callback :: Function.of_arity(1)) :~ Pict:
  Pict.from_handle(rkt.interactive(p.snapshot().handle, callback))

fun is_printing():
  rkt.#{printing?}
  
fun is_condensing():
  rkt.#{condense?}
  
fun start_at_recent():
  rkt.#{start-at-recent-slide}()

fun retract_recent():
  rkt.#{retract-most-recent-slide}()
