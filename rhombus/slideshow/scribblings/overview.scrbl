#lang scribble/rhombus/manual

@(import:
    meta_label:
      rhombus open
      slideshow open      
      draw.Font)

@(def pict_doc = ModulePath 'lib("rhombus/pict/scribblings/rhombus-pict.scrbl")')

@title(~tag: "overview"){Using Slideshow in Rhombus}

The main function provided by the @rhombusmodname(slideshow) library is
@rhombus(slide):

@itemlist(
  
@item{When the @rhombus(slide) function is given a
 @tech(~doc: pict_doc){static pict}, it registers a single slide with the
 pict. If a title is given as a @rhombus(~title) argument to
 @rhombus(slide), the title is added to the top of the pict. Whether or
 not a title is provided, the pict is combined with a blank pict that
 represents the slide client area, and it is positioned based on a
 @rhombus(~layout) argument that defaults to centering the pict (unless
 it's too tall, in which case the pict is top-aligned to the client area
 of the screen).}

@item{When the @rhombus(slide) function is given an
 @tech(~doc: pict_doc){animated pict}, it registers a slide for each
 @tech(~doc: pict_doc){epoch} in the pict's
 @tech(~doc: pict_doc){duration}. For each epoch with a non-@rhombus(0)
 @tech(~doc: pict_doc){extent}, additional auto-advancing slides are
 registered to render a transition between stopping slides. Arguments for
 @rhombus(~title) and @rhombus(~layout) are used to compose each
 registered slide, the same as for a static-pict slide.}

)

Thus, a presentation can be generated by calling @rhombus(slide) many
times to register a sequence of static picts, calling @rhombus(slide)
once with an animated pict that implements many slides at once,
or---most commonly---a hybrid of those approaches.

@section{Multiple versus Single @rhombus(slide) Calls}

For example, this talk

@rhombusblock(
  slide(@t{Hello})
  slide(@t{World})
)

and this talk

@rhombusblock(
  slide(switch(@t{Hello},
               @t{World}))
)

produce the same result, which is a slide presentation that has two
slides, ``Hello'' followed by ``World.''

Here's an example that takes more advantage of passing a single animated
pict to @rhombus(slide)---where the @rhombus(Pict.sustain) call is
needed to create an ending slide with ``World'' fully faded in:

@rhombusblock(
  fun fade_out(p :: Pict): animate(fun (n): p.alpha(1-n))
  fun fade_in(p :: Pict): animate(fun (n): p.alpha(n))

  slide(overlay(fade_out(@t{Hello}),
                fade_in(@t{World}).sustain()))
)

Even in that case, the same effect could be ahcieved with two
@rhombus(slide) calls, avoiding the need for @rhombus(Pict.sustain), but
requiring repeition of the ``World'' pict:

@rhombusblock(
  def world = @t{World}
  slide(overlay(fade_out(@t{Hello}),
                fade_in(world)))
  slide(world)
)

This last example works only because ``World'' is positioned the same on
the screen whether or not it is centered with respect to ``Hello.'' It's
generally a good strategy to have transitions arrive at a same-sized
pict, but when that's inconvenient, a single animated pict is often
better.

@section{The @rhombus(slide) Staging Sublanguage}

Suppose that instead of fading from ``Hello'' to ``World'', we want to
end up with both ``Hello'' and ``World'' on the ending slide but reveal
them one at a time. We could implement that using @rhombus(sequential):

@rhombusblock(
  slide(stack(~sep: 24,
              & sequential(@t{Hello},
                           @t{World})))
)

Two aspects of this example are especially common in slide
presentations: vertical layout of multiple picts (especially text) with
some space in between, and staged display of the stacked components.
Because those patterns are so common, @rhombus(slide) includes some
shorthands to implement them. First, when @rhombus(slide) receives
multipl pict arguments, it combines them with @rhombus(stack) and an
amount of space that defaults to @rhombus(slide.gap), which is the
constant @rhombus(24).

@rhombusblock(
  slide(@t{Hello},
        @t{World})
)

Second, the special value @rhombus(slide.next) is recognized as a
separator in a sequence of picts. The separator causes a stack of picts
after the @rhombus(slide.next) to be shifted sequentially after a stack
of picts before @rhombus(slide.next), achieving the same result as
@rhombus(stack) and @rhombus(sequential) above:

@rhombusblock(
  slide(@t{Hello},
        slide.next,
        @t{World})
)
