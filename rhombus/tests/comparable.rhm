#lang rhombus

use_static

check 1 < 2 ~is #true
check 1 <= 2 ~is #true
check 1 compares_equal 2 ~is #false
check 1 compares_unequal 2 ~is #true
check 1 >= 2 ~is #false
check 2 >= 2 ~is #true
check 1 > 2 ~is #false
check 10 < 2 ~is #false
check 10 <= 2 ~is #false
check 10 <= 10 ~is #true
check 10 compares_equal 10 ~is #true
check 10 compares_unequal 10 ~is #false
check 10 >= 2 ~is #true
check 10 > 2 ~is #true
  
check 1/2 < 2 ~is #true
check 1/2 <= 2 ~is #true
check 1/2 compares_equal 2 ~is #false
check 1/2 compares_unequal 2 ~is #true
check 1/2 >= 2 ~is #false
check 1/2 > 2 ~is #false
  
check "a"[0] < "b"[0] ~is #true
check "a"[0] <= "b"[0] ~is #true
check "a"[0] compares_equal "b"[0] ~is #false
check "a"[0] compares_unequal "b"[0] ~is #true
check "a"[0] >= "b"[0] ~is #false
check "a"[0] >= "a"[0] ~is #true
check "a"[0] > "b"[0] ~is #false
check "a"[0] < "B"[0] ~is #false
check "a"[0] <= "B"[0] ~is #false
check "a"[0] <= "a"[0] ~is #true
check "a"[0] compares_equal "a"[0] ~is #true
check "a"[0] compares_unequal "a"[0] ~is #false
check "a"[0] >= "B"[0] ~is #true
check "a"[0] > "B"[0] ~is #true
  
check "a" < "b" ~is #true
check "a" <= "b" ~is #true
check "a" compares_equal "b" ~is #false
check "a" compares_unequal "b" ~is #true
check "a" >= "b" ~is #false
check "a" >= "a" ~is #true
check "a" > "b" ~is #false
check "a" < "B" ~is #false
check "a" <= "B" ~is #false
check "a" <= "a" ~is #true
check "a" compares_equal "a" ~is #true
check "a" compares_unequal "a" ~is #false
check "a" >= "B" ~is #true
check "a" > "B" ~is #true
  
check #"a" < #"b" ~is #true
check #"a" <= #"b" ~is #true
check #"a" compares_equal #"b" ~is #false
check #"a" >= #"b" ~is #false
check #"a" >= #"a" ~is #true
check #"a" > #"b" ~is #false
check #"a" < #"B" ~is #false
check #"a" <= #"B" ~is #false
check #"a" <= #"a" ~is #true
check #"a" compares_equal #"a" ~is #true
check #"a" >= #"B" ~is #true
check #"a" > #"B" ~is #true

check #'a < #'b ~is #true
check #'a <= #'b ~is #true
check #'a compares_equal #'b ~is #false
check #'a compares_unequal #'b ~is #true
check #'a >= #'b ~is #false
check #'a >= #'a ~is #true
check #'a > #'b ~is #false
check #'a < #'B ~is #false
check #'a <= #'B ~is #false
check #'a <= #'a ~is #true
check #'a compares_equal #'a ~is #true
check #'a compares_unequal #'a ~is #false
check #'a >= #'B ~is #true
check #'a > #'B ~is #true

check #'~a < #'~b ~is #true
check #'~a <= #'~b ~is #true
check #'~a compares_equal #'~b ~is #false
check #'~a compares_unequal #'~b ~is #true
check #'~a >= #'~b ~is #false
check #'~a >= #'~a ~is #true
check #'~a > #'~b ~is #false
check #'~a < #'~B ~is #false
check #'~a <= #'~B ~is #false
check #'~a <= #'~a ~is #true
check #'~a compares_equal #'~a ~is #true
check #'~a compares_unequal #'~a ~is #false
check #'~a >= #'~B ~is #true
check #'~a > #'~B ~is #true

// checks static-info intersection:
check (if #true | 1 | 2.0) < (if #false | 3/2 | 4+5) ~is #true
// checks static-info union:
block:
  let a :: Real = 5
  check a <= a ~is #true

block:
  use_dynamic
  check dynamic(1) < dynamic(2) ~is #true
  check dynamic(#{#\a}) < dynamic(#{#\b}) ~is #true
  check dynamic("a") < dynamic("b") ~is #true
  check dynamic(#"a") < dynamic(#"b") ~is #true
  check dynamic(#'a) < dynamic(#'b) ~is #true
  check dynamic(#'~a) < dynamic(#'~b) ~is #true

  check dynamic(1) <= dynamic(2) ~is #true
  check dynamic(#{#\a}) <= dynamic(#{#\b}) ~is #true
  check dynamic("a") <= dynamic("b") ~is #true
  check dynamic(#"a") <= dynamic(#"b") ~is #true
  check dynamic(#'a) <= dynamic(#'b) ~is #true
  check dynamic(#'~a) <= dynamic(#'~b) ~is #true

  check dynamic(1) >= dynamic(2) ~is #false
  check dynamic(#{#\a}) >= dynamic(#{#\b}) ~is #false
  check dynamic("a") >= dynamic("b") ~is #false
  check dynamic(#"a") >= dynamic(#"b") ~is #false
  check dynamic(#'a) >= dynamic(#'b) ~is #false
  check dynamic(#'~a) >= dynamic(#'~b) ~is #false

  check dynamic(1) > dynamic(2) ~is #false
  check dynamic(#{#\a}) > dynamic(#{#\b}) ~is #false
  check dynamic("a") > dynamic("b") ~is #false
  check dynamic(#"a") > dynamic(#"b") ~is #false
  check dynamic(#'a) > dynamic(#'b) ~is #false
  check dynamic(#'~a) > dynamic(#'~b) ~is #false

  check dynamic(1) compares_equal dynamic(2) ~is #false
  check dynamic(#{#\a}) compares_equal dynamic(#{#\b}) ~is #false
  check dynamic("a") compares_equal dynamic("b") ~is #false
  check dynamic(#"a") compares_equal dynamic(#"b") ~is #false
  check dynamic(#'a) compares_equal dynamic(#'b) ~is #false
  check dynamic(#'~a) compares_equal dynamic(#'~b) ~is #false

  check dynamic(1) compares_unequal dynamic(2) ~is #true
  check dynamic(#{#\a}) compares_unequal dynamic(#{#\b}) ~is #true
  check dynamic("a") compares_unequal dynamic("b") ~is #true
  check dynamic(#"a") compares_unequal dynamic(#"b") ~is #true
  check dynamic(#'a) compares_unequal dynamic(#'b) ~is #true
  check dynamic(#'~a) compares_unequal dynamic(#'~b) ~is #true

class A(v):
  nonfinal
  implements Comparable
  override method compare_to(other :~ A):
    v - other.v

class B():
  nonfinal
  extends A
  override method compare_to(other :~ A):
    other.v - v

class C():
  extends B

interface I3:
  extends Comparable

class A3(v):
  implements I3
  override method compare_to(other :~ A3):
    v - other.v

class A4(v):
  private implements Comparable
  private override method compare_to(other :~ A4):
    v - 2 * other.v

check:
  A(1) < A(2) ~is #true
  A(1) < A(1) ~is #false
  A(1) < A(-1) ~is #false
  A(1) <= A(2) ~is #true
  A(1) <= A(1) ~is #true
  A(1) <= A(-1) ~is #false
  A(1) compares_equal A(1) ~is #true
  A(1) compares_equal A(2) ~is #false
  A(1) compares_unequal A(2) ~is #true
  A(1) compares_unequal A(1) ~is #false
  A(2) >= A(1) ~is #true
  A(1) >= A(1) ~is #true
  A(-1) >= A(1) ~is #false
  A(2) > A(1) ~is #true
  A(1) > A(1) ~is #false
  A(-1) > A(1) ~is #false

  B(2) < B(1) ~is #true
  B(2) > B(1) ~is #false

  C(2) < C(1) ~is #true
  C(2) > C(1) ~is #false

  C(2) < B(1) ~is #true
  B(2) > C(1) ~is #false

  A3(2) < A3(4) ~is #true
  A3(2) > A3(4) ~is #false

  A4(2) < A4(2) ~is #true
  A4(2) > A4(2) ~is #false

  (if #true | C(2) | B(2)) < B(1) ~is #true

  A(1).compare_to(A(2)) compares_equal A(1).compare_to(A(2)) ~is #true

block:
  use_dynamic
  check:
    dynamic(A(1)) < B(1) ~throws values(
      "cannot compare a comparable object and other comparable object",
      "two comparable objects must share the same `compare_to` implementation",
    )

check:
  A(1) is_a Comparable ~is #true
  B(1) is_a Comparable ~is #true
  C(1) is_a Comparable ~is #true
  A4(1) is_a Comparable ~is #true

  { 1: 2 } is_a Comparable ~is #false
  { 1, 2 } is_a Comparable ~is #false
  [1, 2] is_a Comparable ~is #false
  1 is_a Comparable ~is #true
  1/2 is_a Comparable ~is #true
  1.0 is_a Comparable ~is #true
  #inf is_a Comparable ~is #true
  math.sqrt(-1) is_a Comparable ~is #false
  "apple" is_a Comparable ~is #true
  #"apple" is_a Comparable ~is #true
  #'apple is_a Comparable ~is #true
  #'~apple is_a Comparable ~is #true

check:
  (MutableMap{ 1: 2 } :~ Appendable)
    ++ MutableMap{ 3: 4 } ~throws values(
    "contract violation",
    "expected: Appendable",
    "MutableMap{1: 2}",
  )
  (MutableSet{ 1, 2 } :~ Appendable)
    ++ MutableSet{ 3, 4 } ~throws values(
    "contract violation",
    "expected: Appendable",
    "MutableSet{1, 2}",
  )

block:
  use_dynamic
  fun gen():
    // check that generated `compare_to` method is fresh
    class A():
      implements Comparable
      override method compare_to(other):
        0
    A()
  check:
    gen() < gen() ~throws values(
      "cannot compare a comparable object and other comparable object",
      "two comparable objects must share the same `compare_to` implementation",
    )
    dynamic(1) < 2 ~is #true
    dynamic(#'a) > #'z ~is #false

block:
  class Broken():
    implements Comparable
    override method compare_to(other):
      "no"
  check Broken() < Broken() ~throws values(
    "result does not satisfy annotation",
    "Int",
    "\"no\"",
  )

block:
  class Broken():
    implements Comparable
    override method compare_to(other):
      values("oops", "wow")
  check Broken() < Broken() ~throws values(
    "results do not satisfy annotation",
    "Int",
    "\"oops\"", "\"wow\"",
  )
  check (Broken() :: Comparable) < Broken() ~throws values(
    "results do not satisfy annotation",
    "Int",
    "\"oops\"", "\"wow\"",
  )
  check Broken() < (Broken() :: Comparable) ~throws values(
    "results do not satisfy annotation",
    "Int",
    "\"oops\"", "\"wow\"",
  )

check:
  ~eval
  use_static
  1 < "a"
  ~throws "incompatible specializations from arguments"

check:
  ~eval
  use_static
  "a" < 1
  ~throws "incompatible specializations from arguments"

check:
  ~eval
  use_static
  class A(v):
    implements Comparable
    override method compare_to(other :~ A):
      v - other.v
  class A2(v):
    implements Comparable
    override method compare_to(other :~ A2):
      v - other.v
  A(0) < A2(1)
  ~throws "incompatible specializations from arguments"

check:
  ~eval
  use_static
  class A(v):
    implements Comparable
    override method compare_to(other :~ A):
      v - other.v
  class A2(v):
    implements Comparable
    override method compare_to(other :~ A2):
      v - other.v
  fun (x): (if x | A(0) | A2(1)) < x
  ~throws "specialization not known"

check:
  ~eval
  use_static
  class A(v):
    nonfinal
    implements Comparable
    override method compare_to(other :~ A):
      v - other.v
  class B():
    nonfinal
    extends A
    override method compare_to(other :~ A):
      other.v - v
  A(0) < B(1)
  ~throws "incompatible specializations from arguments"
