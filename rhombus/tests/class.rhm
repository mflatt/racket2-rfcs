#lang rhombus
import: "check.rhm" open

use_static
  
check:
  class Posn(x, y)
  def p = Posn(1, 2)
  [p is_a Posn, p.x, p.y]
  [#true, 1, 2]

check:
  ~eval_exn
  class Posn(x, y)
  class Posn3D(z):
    extends Posn
  "superclass is final"

check:
  ~eval_exn
  class Posn(x, x)
  "duplicate field name"

check:
  ~eval_exn
  class Posn(x, y):
    field x = 0
  "duplicate field name"

check:
  ~eval_exn
  class Posn(x, y):
    nonfinal
  class Posn3D(x):
    extends Posn
  "field name already exists in superclass"

check:
  class Posn(~x, y)
  def p = Posn(~x: 1, 2)
  def p2 = Posn(2, ~x: 1)
  [p.x, p.y, p2.x, p2.y]
  [1, 2, 1, 2]

check:
  class Posn(~x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
  def p = Posn3D(~x: 1, 2, 3)
  def p2 = Posn3D(2, 3, ~x: 1)
  [p.x, p.y, p.z, p2.x, p2.y, p2.z]
  [1, 2, 3, 1, 2, 3]

check:
  class Posn(x, y):
    nonfinal
  class Posn3D(~z):
    extends Posn
  def p = Posn3D(1, 2, ~z: 3)
  def p2 = Posn3D(~z: 3, 1, 2)
  [p.x, p.y, p.z, p2.x, p2.y, p2.z]
  [1, 2, 3, 1, 2, 3]

check:
  class Posn(~x, y):
    nonfinal
  class Posn3D(~z: zz):
    extends Posn
  def p = Posn3D(~x: 1, 2, ~z: 3)
  def p2 = Posn3D(~z: 3, 2, ~x: 1)
  [p.x, p.y, p.zz, p2.x, p2.y, p2.zz]
  [1, 2, 3, 1, 2, 3]

check:
  class Posn(x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
  def p = Posn3D(1, 2, 3)
  [p is_a Posn, p is_a Posn3D, p.x, p.y, p.z,
   Posn(1, 2) is_a Posn3D]
  [#true, #true, 1, 2, 3,
   #false]

check:
  class Posn(x, y):
    constructor (z):
      super(z+1, z-1)
  def p = Posn(1)
  [p.x, p.y]
  [2, 0]

check:
  class Posn(x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
    constructor (z):
      super(z+1, z+2)(z+3)
  def p = Posn3D(1)
  [p.x, p.y, p.z]
  [2, 3, 4]

check:
  class Posn(x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
    nonfinal
  class Posn4D(w):
    extends Posn3D
    constructor (z):
      super(z+1, z+2, z+3)(z+4)
  def p = Posn4D(1)
  [p.x, p.y, p.z, p.w]
  [2, 3, 4, 5]

check:
  class Posn(x, y):
    nonfinal
    constructor:
      fun (y, x):
        super(x, y)
  class Posn3D(z):
    extends Posn
    constructor:
      fun (z):
        super(z+1, z+2)(z+3)
  def p = Posn3D(1)
  [p.x, p.y, p.z]
  [3, 2, 4]

check:
  class Posn(x, y):
    nonfinal
    constructor:
      fun (y, x):
        super(x, y)
  class Posn3D(z):
    extends Posn
    nonfinal
    constructor:
      fun (z):
        super(z+1, z+2)(z+3)
  class Posn4D(w):
    extends Posn3D
    nonfinal
    constructor:
      fun (z):
        super(z+1)(z+5)
  def p = Posn4D(1)
  [p.x, p.y, p.z, p.w]
  [4, 3, 5, 6]

check:
  class Posn(x, y):
    nonfinal
    constructor:
      fun
      | (~x: x, ~y: y):
          super(x, y)
      | (x):
          super(x, 0)
  class Posn3D(z):
    extends Posn
    constructor:
      fun
      | (z):
          super(z+1)(z+3)
      | (x, y, z):
          super(~x: x, ~y: y)(z)
  def p = Posn3D(1)
  def p2 = Posn3D(10, 20, 30)
  [p.x, p.y, p.z,
   p2.x, p2.y, p2.z]
  [2, 0, 4,
   10, 20, 30]

check:
  use_dynamic
  class Posn(x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
  def p = dynamic(Posn3D(1, 2, 3))
  [p.x, p.y, p.z]
  [1, 2, 3]

check:
  import rhombus/meta open
  class Posn(x, y):
    nonfinal
    internal _Posn
    // external view flips `y` and `x`
    constructor:
      fun (y, x):
        _Posn(x, y)
    binding:
      rule
      | '()($y, $x)':
          '_Posn($x, $y)'
      | '()($v)':
          '_Posn($v, 0)'
    annotation:
      rule
      | '().of($x, $y)':
          '_Posn.of($y, $x)'
      | '()': '_Posn'    
  def p = Posn(0, 2)
  def Posn(yy, xx) = p
  def Posn(a) = p    
  [p.y, p.x, yy, xx, a,
   p is_a Posn,
   Posn(1, "2") is_a Posn.of(Integer, String)]
  [0, 2, 0, 2, 2,
   #true,
   #true]

check:
  class Posn(x, y):
    nonfinal
    field w = 0
  class Posn3D(z):
    extends Posn
  def p1 = Posn(10, 20)
  def p = Posn3D(1, 2, 3)
  [[p1.x, p1.y, p1.w],
   [p.x, p.y, p.w, p.z]]
  [[10, 20, 0],
   [1, 2, 0, 3]]

check:
  class Posn(~x, y):
    nonfinal
    field w = 0
  class Posn3D(z):
    extends Posn
  def p1 = Posn(20, ~x: -10)
  def p = Posn3D(2, ~x: 1, 3)
  [[p1.x, p1.y, p1.w],
   [p.x, p.y, p.w, p.z]]
  [[-10, 20, 0],
   [1, 2, 0, 3]]

check:
  class Posn(~x, y):
    nonfinal
    field w = 0
    internal _Posn
  class Posn3D(z):
    extends Posn
    internal _Posn3D
  def p1 = Posn(20, ~x: -10)
  def p = Posn3D(2, ~x: 1, 3)
  def ip1 = _Posn(20, ~x: -10)
  def ip = _Posn3D(2, ~x: 1)(3)
  fun get(p1 :: Posn, p :: Posn3D):
    [[p1.x, p1.y, p1.w],
     [p.x, p.y, p.w, p.z]]
  [get(p1, p), get(ip1, ip)]
  [[[-10, 20, 0], [1, 2, 0, 3]],
   [[-10, 20, 0], [1, 2, 0, 3]]]

check:
  class Posn(~x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
    constructor:
      fun(x, y, z):
        super(~x: 1, y)(z)
  def p2 = Posn(~x: 1, 2)
  def p3 = Posn3D(1, 2, 3)
  [[p2.x, p2.y], [p3.x, p3.y, p3.z]]
  [[1, 2], [1, 2, 3]]

check:
  class Posn(~x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
    nonfinal
    constructor:
      fun(x, y, z):
        super(~x: 1, y)(z)
  class Posn4D(~w):
    extends Posn3D
    constructor:
      fun(x, y, z, w):
        super(x, y, z)(~w: w)
  def p2 = Posn(~x: 1, 2)
  def p3 = Posn3D(1, 2, 3)
  def p4 = Posn4D(1, 2, 3, 4)
  [[p2.x, p2.y],
   [p3.x, p3.y, p3.z],
   [p4.x, p4.y, p4.z, p4.w]]
  [[1, 2],
   [1, 2, 3],
   [1, 2, 3, 4]]

check:
  class Posn(~x, y):
    nonfinal
    constructor:
      fun(~ex: x, ~wy: y):
        super(~x: 1, y)
  class Posn3D(z):
    extends Posn
    nonfinal
    constructor:
      fun(x, ~y: y, z):
        super(~ex: 1, ~wy: y)(z)
    internal _Posn3D
  class Posn4D(w):
    extends Posn3D
    constructor:
      fun(x, y, z, w):
        super(x, ~y: y, z)(w)
  def p2 = Posn(~ex: 1, ~wy: 2)
  def p3 = Posn3D(1, ~y: 2, 3)
  def _p3 = _Posn3D(~ex: 1, ~wy: 2)(3)
  def p4 = Posn4D(1, 2, 3, 4)
  [[p2.x, p2.y],
   [p3.x, p3.y, p3.z],
   [_p3.x, _p3.y, _p3.z],
   [p4.x, p4.y, p4.z, p4.w]]
  [[1, 2],
   [1, 2, 3],
   [1, 2, 3],
   [1, 2, 3, 4]]

check:
  class Posn(x, y = 0)
  def p = Posn(1)
  [p.x, p.y]
  [1, 0]

check:
  class Posn(x, y = x):
    nonfinal
  def p = Posn(1)
  [p.x, p.y]
  [1, 1]

check:
  class Posn(~x, y = x):
    nonfinal
  def p = Posn(~x: 1)
  def p2 = Posn(~x: -1, 2)
  [p.x, p.y, p2.x, p2.y]
  [1, 1, -1, 2]

check:
  class Posn3D(~x = 10, y, ~z: z = x+y)
  def p = Posn3D(2)
  def p2 = Posn3D(2, ~z: 3)
  def p3 = Posn3D(2, ~x: 3)
  def p4 = Posn3D(~z: 0, 2, ~x: 3)
  [[p.x, p.y, p.z],
   [p2.x, p2.y, p2.z],
   [p3.x, p3.y, p3.z],
   [p4.x, p4.y, p4.z]]
  [[10, 2, 12],
   [10, 2, 3],
   [3, 2, 5],
   [3, 2, 0]]

check:
  ~eval_exn
  class Posn(x = 0, y)
  "without default after"

check:
  ~eval_exn
  class Posn(x, y = 0):
    nonfinal
  class Posn3D(z):
    extends Posn
  "field needs a default"

check:
  ~eval_exn
  class Posn(x, y = no_such_variable)
  "no_such_variable: unbound identifier"

check:
  ~eval_exn
  class Posn(the_x, the_y = 0):
    nonfinal
  class Posn3D(z = the_y):
    extends Posn
  "the_y: unbound identifier"

check:
  ~exn
  class Posn(x :: Integer, y :: Integer)
  Posn("x", 0)
  "value does not match annotation"

check:
  ~exn
  class Posn(mutable x :: Integer, y :: Integer)
  Posn("x", 0)
  "value does not match annotation"

check:
  class Posn(mutable x :: Integer, y :: Integer):
    method m():
      x := 8
  def p = Posn(2, 0)
  [p.x, p.x := 5, p.x, p.y, p.m(), p.x]
  [2, #void, 5, 0, #void, 8]

check:
  class Posn(x :: Integer, mutable y :: Integer)
  def p = Posn(2, 0)
  [p.y, p.y := 5, p.y, p.x]
  [0, #void, 5, 2]

check:
  ~exn
  class Posn(mutable x :: Integer, y :: Integer)
  Posn("x", 0).x := "oops"
  "value does not match annotation"

check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
  class Posn3D(z):
    extends Posn
    nonfinal
  class Posn4D(w):
    extends Posn3D
    nonfinal
  def p = Posn4D(1, ~y: 2, 3, 6)
  def Posn(a2, ~y: b2) = p
  def Posn3D(a3, ~y: b3, c3) = p
  def Posn4D(a4, ~y: b4, c4, d4) = p
  [[a2, b2],
   [a3, b3, c3],
   [a4, b4, c4, d4]]
  [[1, 2],
   [1, 2, 3],
   [1, 2, 3, 6]]

check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
  class Posn3D(z):
    extends Posn
    internal _Posn3D
    binding:
      rule '()($x, $y ..., $z)': 'Posn($x, ~y: $y ...) && _Posn3D($z)'
  def p = Posn3D(1, ~y: 2, 3)
  def Posn(a2, ~y: b2) = p
  def Posn3D(a3, b3, c3) = p
  [[a2, b2],
   [a3, b3, c3]]
  [[1, 2],
   [1, 2, 3]]

check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
    internal _Posn
    binding:
      rule '()(X $x, Y $y)': '_Posn($x, ~y: $y)'
  class Posn3D(z):
    extends Posn
    nonfinal
    internal _Posn3D
    binding:
      rule '()[$x, $y ..., $z]': 'Posn(X $x, Y $y ...) && _Posn3D($z)'
  class Posn4D(w):
    extends Posn3D
    nonfinal
    internal _Posn4D
    binding:
      rule '()($x, ~y: $y, $z, $w)': 'Posn3D[$x, $y, $z] && _Posn4D($w)'
  def p = Posn4D(1, ~y: 2, 3, 6)
  def Posn(X a2, Y b2) = p
  def Posn3D[a3, b3, c3] = p
  def Posn4D(a4, ~y: b4, c4, d4) = p
  [[a2, b2],
   [a3, b3, c3],
   [a4, b4, c4, d4]]
  [[1, 2],
   [1, 2, 3],
   [1, 2, 3, 6]]
  
check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
  class Posn3D(z):
    extends Posn
    nonfinal
  class Posn4D(w):
    extends Posn3D
    nonfinal
  def p = Posn4D(1, ~y: "2", symbol'three', keyword'~four')
  p :: Posn
  p :: Posn.of(Integer, ~y: String)
  p :: Posn3D
  p :: Posn3D.of(Integer, ~y: String, Symbol)
  p :: Posn4D
  p :: Posn4D.of(Integer, ~y: String, Symbol, Keyword)
  "ok plain annotation"
  "ok plain annotation"

check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
  class Posn3D(z):
    extends Posn
    internal _Posn3D
    annotation:
      rule | '().of($x, $y ..., $z)': 'Posn.of($x, ~y: $y ...) && _Posn3D.of($z)'
           | '()': '_Posn3D'
  def p = Posn3D(1, ~y: "2", symbol'three')
  p :: Posn
  p :: Posn.of(Integer, ~y: String)
  p :: Posn3D
  p :: Posn3D.of(Integer, String, Symbol)
  "ok plain+custom annotation"
  "ok plain+custom annotation"

check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
    internal _Posn
    annotation:
      rule | '() $dot of(X $x, Y $y)': '_Posn.of($x, ~y: $y)'
           | '()': '_Posn'
  class Posn3D(z):
    extends Posn
    nonfinal
    internal _Posn3D
    annotation:
      rule | '() $dot of[$x, $y ..., $z]': 'Posn.of(X $x, Y $y ...) && _Posn3D.of($z)'
           | '()': '_Posn3D'
  class Posn4D(w):
    extends Posn3D
    nonfinal
    internal _Posn4D
    annotation:
      rule | '() $dot of($x, ~y: $y, $z, $w)': 'Posn3D.of[$x, $y, $z] && _Posn4D.of($w)'
           | '()': '_Posn4D'
  def p = Posn4D(1, ~y: "2", symbol'three', keyword'~four')
  p :: Posn
  p :: Posn.of(X Integer, Y String)
  p :: Posn3D
  p :: Posn3D.of[Integer, String, Symbol]
  p :: Posn4D
  p :: Posn4D.of(Integer, ~y: String, Symbol, Keyword)
  "ok plain+custom annotations"
  "ok plain+custom annotations"

check:
  fun lookup_specs(make, model): [12, 25]
  class Car(make, model, private mpg):
    private field gas = 0
    constructor(make, model):
      def [tank_size, mpg] = lookup_specs(make, model)
      def car: super(make, model, mpg)
      car.gas := tank_size
      car
    method go(dist):
      gas := gas - dist/mpg
      gas
  def c = Car("Mazda", "Miata")
  c.go(100)
  8

check:
  class Posn(x, y):
    field w :: Integer = 0
    field name -: String: "ok"
  Posn(1, 2).name +& Posn(3, 4).w
  "ok0"

check:
  def mutable n = 0
  class Posn(x, y):
    field color: "red" +& begin: n := n + 1; n
  [Posn(1, 2).color, Posn(1, 2).color]
  ["red1", "red2"]

// Make sure static info flows through field and method
// references without `this.`
check:
  class Posn(x, y)
  class PosnUser(p :: Posn):
    method m():
      p.x + get().y
    method get() :: Posn:
      p
  PosnUser(Posn(1, 2)).m()
  3

begin:
  class Posn(x, y):
    nonfinal
  class Posn3D(z :: Integer):
    extends Posn
  check:
    ~exn
    Posn3D(1, 2, "x")
    "annotation"
  check:
    Posn3D("1", "2", 3)
    Posn3D("1", "2", 3)

// refer to class as annotation for a field
begin:
  class Posn(x, y)
  class Dir(loc -: Posn, content :: List.of(Dir))
  Dir(Posn(0, 0), [Dir(Posn(1, 2), [])]).content[0].loc.x

begin:
  class Posn(x, y)
  class Dir(loc -: Posn, content :: List.of(Dir)):
    method get() :: Dir: this
  Dir(Posn(0, 0), [Dir(Posn(1, 2), [])]).content[0].get().loc.x
