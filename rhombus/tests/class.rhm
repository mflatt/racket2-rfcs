#lang rhombus
import:
  meta:
    rhombus expose: macro

use_static
  
check:
  class Posn(x, y)
  def p = Posn(1, 2)
  [p is_a Posn, p.x, p.y]
  ~is [#true, 1, 2]

check:
  ~eval
  class Posn(x, y)
  class Posn3D(z):
    extends Posn
  ~raises "superclass is final"

check:
  ~eval
  class Posn(x, x)
  ~raises "duplicate field name"

check:
  ~eval
  class Posn(x, y):
    field x = 0
  ~raises "duplicate field name"

check:
  ~eval
  class Posn(x, y):
    nonfinal
  class Posn3D(x):
    extends Posn
  ~raises "field name already exists in superclass"

check:
  class Posn(~x, y)
  def p = Posn(~x: 1, 2)
  def p2 = Posn(2, ~x: 1)
  [p.x, p.y, p2.x, p2.y]
  ~is [1, 2, 1, 2]

check:
  class Posn(~x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
  def p = Posn3D(~x: 1, 2, 3)
  def p2 = Posn3D(2, 3, ~x: 1)
  [p.x, p.y, p.z, p2.x, p2.y, p2.z]
  ~is [1, 2, 3, 1, 2, 3]

check:
  class Posn(x, y):
    nonfinal
  class Posn3D(~z):
    extends Posn
  def p = Posn3D(1, 2, ~z: 3)
  def p2 = Posn3D(~z: 3, 1, 2)
  [p.x, p.y, p.z, p2.x, p2.y, p2.z]
  ~is [1, 2, 3, 1, 2, 3]

check:
  class Posn(~x, y):
    nonfinal
  class Posn3D(~z: zz):
    extends Posn
  def p = Posn3D(~x: 1, 2, ~z: 3)
  def p2 = Posn3D(~z: 3, 2, ~x: 1)
  [p.x, p.y, p.zz, p2.x, p2.y, p2.zz]
  ~is [1, 2, 3, 1, 2, 3]

check:
  class Posn(x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
  def p = Posn3D(1, 2, 3)
  [p is_a Posn, p is_a Posn3D, p.x, p.y, p.z,
   Posn(1, 2) is_a Posn3D]
  ~is [#true, #true, 1, 2, 3,
       #false]

check:
  class Posn(x, y):
    constructor (z):
      super(z+1, z-1)
  def p = Posn(1)
  [p.x, p.y]
  ~is [2, 0]

check:
  class Posn(x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
    constructor (z):
      super(z+1, z+2)(z+3)
  def p = Posn3D(1)
  [p.x, p.y, p.z]
  ~is [2, 3, 4]

check:
  class Posn(x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
    nonfinal
  class Posn4D(w):
    extends Posn3D
    constructor (z):
      super(z+1, z+2, z+3)(z+4)
  def p = Posn4D(1)
  [p.x, p.y, p.z, p.w]
  ~is [2, 3, 4, 5]

check:
  class Posn(x, y):
    nonfinal
    constructor:
      fun (y, x):
        super(x, y)
  class Posn3D(z):
    extends Posn
    constructor:
      fun (z):
        super(z+1, z+2)(z+3)
  def p = Posn3D(1)
  [p.x, p.y, p.z]
  ~is [3, 2, 4]

check:
  class Posn(x, y):
    nonfinal
    constructor:
      fun (y, x):
        super(x, y)
  class Posn3D(z):
    extends Posn
    nonfinal
    constructor:
      fun (z):
        super(z+1, z+2)(z+3)
  class Posn4D(w):
    extends Posn3D
    nonfinal
    constructor:
      fun (z):
        super(z+1)(z+5)
  def p = Posn4D(1)
  [p.x, p.y, p.z, p.w]
  ~is [4, 3, 5, 6]

check:
  class Posn(x, y):
    nonfinal
    constructor:
      fun
      | (~x: x, ~y: y):
          super(x, y)
      | (x):
          super(x, 0)
  class Posn3D(z):
    extends Posn
    constructor:
      fun
      | (z):
          super(z+1)(z+3)
      | (x, y, z):
          super(~x: x, ~y: y)(z)
  def p = Posn3D(1)
  def p2 = Posn3D(10, 20, 30)
  [p.x, p.y, p.z,
   p2.x, p2.y, p2.z]
  ~is [2, 0, 4,
       10, 20, 30]

check:
  use_dynamic
  class Posn(x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
  def p = dynamic(Posn3D(1, 2, 3))
  [p.x, p.y, p.z]
  ~is [1, 2, 3]

check:
  import rhombus/meta open
  class Posn(x, y):
    nonfinal
    internal _Posn
    // external view flips `y` and `x`
    constructor:
      fun (y, x):
        _Posn(x, y)
    binding:
      macro
      | '()($y, $x)':
          '_Posn($x, $y)'
      | '()($v)':
          '_Posn($v, 0)'
    annotation 'Posn': '_Posn'
    annot.macro 'of($x, $y)':
      '_Posn.of($y, $x)'
    export: of
  def p = Posn(0, 2)
  def Posn(yy, xx) = p
  def Posn(a) = p    
  [p.y, p.x, yy, xx, a,
   p is_a Posn,
   Posn(1, "2") is_a Posn.of(Int, String)]
  ~is [0, 2, 0, 2, 2,
       #true,
       #true]

check:
  class Posn(x, y):
    nonfinal
    field w = 0
  class Posn3D(z):
    extends Posn
  def p1 = Posn(10, 20)
  def p = Posn3D(1, 2, 3)
  [[p1.x, p1.y, p1.w],
   [p.x, p.y, p.w, p.z]]
  ~is [[10, 20, 0],
       [1, 2, 0, 3]]

check:
  class Posn(~x, y):
    nonfinal
    field w = 0
  class Posn3D(z):
    extends Posn
  def p1 = Posn(20, ~x: -10)
  def p = Posn3D(2, ~x: 1, 3)
  [[p1.x, p1.y, p1.w],
   [p.x, p.y, p.w, p.z]]
  ~is [[-10, 20, 0],
       [1, 2, 0, 3]]

check:
  class Posn(~x, y):
    nonfinal
    field w = 0
    internal _Posn
  class Posn3D(z):
    extends Posn
    internal _Posn3D
  def p1 = Posn(20, ~x: -10)
  def p = Posn3D(2, ~x: 1, 3)
  def ip1 = _Posn(20, ~x: -10)
  def ip = _Posn3D(2, ~x: 1)(3)
  fun get(p1 :: Posn, p :: Posn3D):
    [[p1.x, p1.y, p1.w],
     [p.x, p.y, p.w, p.z]]
  [get(p1, p), get(ip1, ip)]
  ~is [[[-10, 20, 0], [1, 2, 0, 3]],
       [[-10, 20, 0], [1, 2, 0, 3]]]

check:
  class Posn(~x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
    constructor:
      fun(x, y, z):
        super(~x: 1, y)(z)
  def p2 = Posn(~x: 1, 2)
  def p3 = Posn3D(1, 2, 3)
  [[p2.x, p2.y], [p3.x, p3.y, p3.z]]
  ~is [[1, 2], [1, 2, 3]]

check:
  class Posn(~x, y):
    nonfinal
  class Posn3D(z):
    extends Posn
    nonfinal
    constructor:
      fun(x, y, z):
        super(~x: 1, y)(z)
  class Posn4D(~w):
    extends Posn3D
    constructor:
      fun(x, y, z, w):
        super(x, y, z)(~w: w)
  def p2 = Posn(~x: 1, 2)
  def p3 = Posn3D(1, 2, 3)
  def p4 = Posn4D(1, 2, 3, 4)
  [[p2.x, p2.y],
   [p3.x, p3.y, p3.z],
   [p4.x, p4.y, p4.z, p4.w]]
  ~is [[1, 2],
       [1, 2, 3],
       [1, 2, 3, 4]]

check:
  class Posn(~x, y):
    nonfinal
    constructor:
      fun(~ex: x, ~wy: y):
        super(~x: 1, y)
  class Posn3D(z):
    extends Posn
    nonfinal
    constructor:
      fun(x, ~y: y, z):
        super(~ex: 1, ~wy: y)(z)
    internal _Posn3D
  class Posn4D(w):
    extends Posn3D
    constructor:
      fun(x, y, z, w):
        super(x, ~y: y, z)(w)
  def p2 = Posn(~ex: 1, ~wy: 2)
  def p3 = Posn3D(1, ~y: 2, 3)
  def _p3 = _Posn3D(~ex: 1, ~wy: 2)(3)
  def p4 = Posn4D(1, 2, 3, 4)
  [[p2.x, p2.y],
   [p3.x, p3.y, p3.z],
   [_p3.x, _p3.y, _p3.z],
   [p4.x, p4.y, p4.z, p4.w]]
  ~is [[1, 2],
       [1, 2, 3],
       [1, 2, 3],
       [1, 2, 3, 4]]

check:
  class Posn(x, y = 0)
  def p = Posn(1)
  [p.x, p.y]
  ~is [1, 0]

check:
  class Posn(x, y = x):
    nonfinal
  def p = Posn(1)
  [p.x, p.y]
  ~is [1, 1]

check:
  class Posn(~x, y = x):
    nonfinal
  def p = Posn(~x: 1)
  def p2 = Posn(~x: -1, 2)
  [p.x, p.y, p2.x, p2.y]
  ~is [1, 1, -1, 2]

check:
  class Posn3D(~x = 10, y, ~z: z = x+y)
  def p = Posn3D(2)
  def p2 = Posn3D(2, ~z: 3)
  def p3 = Posn3D(2, ~x: 3)
  def p4 = Posn3D(~z: 0, 2, ~x: 3)
  [[p.x, p.y, p.z],
   [p2.x, p2.y, p2.z],
   [p3.x, p3.y, p3.z],
   [p4.x, p4.y, p4.z]]
  ~is [[10, 2, 12],
       [10, 2, 3],
       [3, 2, 5],
       [3, 2, 0]]

check:
  ~eval
  class Posn(x = 0, y)
  ~raises "without default after"

check:
  ~eval
  class Posn(x, y = 0):
    nonfinal
  class Posn3D(z):
    extends Posn
  ~raises "field needs a default"

check:
  ~eval
  class Posn(x, y = no_such_variable)
  Posn(1)
  ~raises "no_such_variable: undefined"

check:
  ~eval
  class Posn(the_x, the_y = 0):
    nonfinal
  class Posn3D(z = the_y):
    extends Posn
  Posn3D(0)
  ~raises "the_y: undefined"

check:
  class Posn(x :: Int, y :: Int)
  Posn("x", 0)
  ~raises "value does not satisfy annotation"

block:
  class Posn(mutable x :: Int, y :: Int)
  check:
    Posn("x", 0) ~raises "value does not satisfy annotation"
    Posn(1, 2) == Posn(1, 2) ~is #false
    Posn(1, 2) != Posn(1, 2) ~is #true
    Posn(1, 2) =*= Posn(1, 2) ~is #true
    Posn(1, 2) ~is_now Posn(1, 2)

check:
  class Posn(mutable x :: Int, y :: Int):
    method m():
      x := 8
  def p = Posn(2, 0)
  [p.x, p.x := 5, p.x, p.y, p.m(), p.x]
  ~is [2, #void, 5, 0, #void, 8]

check:
  class Posn(x :: Int, mutable y :: Int)
  def p = Posn(2, 0)
  [p.y, p.y := 5, p.y, p.x]
  ~is [0, #void, 5, 2]

check:
  class Posn(mutable x :: Int, y :: Int)
  Posn("x", 0).x := "oops"
  ~raises "value does not satisfy annotation"

check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
  class Posn3D(z):
    extends Posn
    nonfinal
  class Posn4D(w):
    extends Posn3D
    nonfinal
  def p = Posn4D(1, ~y: 2, 3, 6)
  def Posn(a2, ~y: b2) = p
  def Posn3D(a3, ~y: b3, c3) = p
  def Posn4D(a4, ~y: b4, c4, d4) = p
  [[a2, b2],
   [a3, b3, c3],
   [a4, b4, c4, d4]]
  ~is [[1, 2],
       [1, 2, 3],
       [1, 2, 3, 6]]

check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
  class Posn3D(z):
    extends Posn
    internal _Posn3D
    binding:
      macro '()($x, $y ..., $z)': 'Posn($x, ~y: $y ...) && _Posn3D($z)'
  def p = Posn3D(1, ~y: 2, 3)
  def Posn(a2, ~y: b2) = p
  def Posn3D(a3, b3, c3) = p
  [[a2, b2],
   [a3, b3, c3]]
  ~is [[1, 2],
       [1, 2, 3]]

check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
    internal _Posn
    binding:
      macro '()(X $x, Y $y)': '_Posn($x, ~y: $y)'
  class Posn3D(z):
    extends Posn
    nonfinal
    internal _Posn3D
    binding:
      macro '()[$x, $y ..., $z]': 'Posn(X $x, Y $y ...) && _Posn3D($z)'
  class Posn4D(w):
    extends Posn3D
    nonfinal
    internal _Posn4D
    binding:
      macro '()($x, ~y: $y, $z, $w)': 'Posn3D[$x, $y, $z] && _Posn4D($w)'
  def p = Posn4D(1, ~y: 2, 3, 6)
  def Posn(X a2, Y b2) = p
  def Posn3D[a3, b3, c3] = p
  def Posn4D(a4, ~y: b4, c4, d4) = p
  [[a2, b2],
   [a3, b3, c3],
   [a4, b4, c4, d4]]
  ~is [[1, 2],
       [1, 2, 3],
       [1, 2, 3, 6]]
  
check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
  class Posn3D(z):
    extends Posn
    nonfinal
  class Posn4D(w):
    extends Posn3D
    nonfinal
  def p = Posn4D(1, ~y: "2", #'three, #'~four)
  p :: Posn
  p :: Posn.of(Int, ~y: String)
  p :: Posn3D
  p :: Posn3D.of(Int, ~y: String, Symbol)
  p :: Posn4D
  p :: Posn4D.of(Int, ~y: String, Symbol, Keyword)
  ~completes
  
check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
  class Posn3D(z):
    extends Posn
    internal _Posn3D
    annotation:
      macro | '()': '_Posn3D'
    annot.macro 'of($x, $y ..., $z)': 'Posn.of($x, ~y: $y ...) && _Posn3D.of($z)'
    export: of
  def p = Posn3D(1, ~y: "2", #'three)
  p :: Posn
  p :: Posn.of(Int, ~y: String)
  p :: Posn3D
  p :: Posn3D.of(Int, String, Symbol)
  ~completes

check:
  import rhombus/meta open
  class Posn(x, ~y):
    nonfinal
    internal _Posn
    annotation:
      macro | '()': '_Posn'
    annot.macro 'of(X $x, Y $y)': '_Posn.of($x, ~y: $y)'
    export: of
  class Posn3D(z):
    extends Posn
    nonfinal
    internal _Posn3D
    annotation:
      macro | '()': '_Posn3D'
    annot.macro 'of[$x, $y ..., $z]': 'Posn.of(X $x, Y $y ...) && _Posn3D.of($z)'
    export: of
  class Posn4D(w):
    extends Posn3D
    nonfinal
    internal _Posn4D
    annotation:
      macro | '()': '_Posn4D'
    annot.macro 'of($x, ~y: $y, $z, $w)': 'Posn3D.of[$x, $y, $z] && _Posn4D.of($w)'
    export: of
  def p = Posn4D(1, ~y: "2", #'three, #'~four)
  p :: Posn
  p :: Posn.of(X Int, Y String)
  p :: Posn3D
  p :: Posn3D.of[Int, String, Symbol]
  p :: Posn4D
  p :: Posn4D.of(Int, ~y: String, Symbol, Keyword)
  ~completes

check:
  fun lookup_specs(make, model): [12, 25]
  class Car(make, model, private mpg):
    private field gas = 0
    constructor(make, model):
      def [tank_size, mpg] = lookup_specs(make, model)
      def car: super(make, model, mpg)
      car.gas := tank_size
      car
    method go(dist):
      gas := gas - dist/mpg
      gas
  def c = Car("Mazda", "Miata")
  c.go(100)
  ~is 8

check:
  class Posn(x, y):
    field w :: Int = 0
    field name :~ String: "ok"
  Posn(1, 2).name +& Posn(3, 4).w
  ~is "ok0"

check:
  def mutable n = 0
  class Posn(x, y):
    field color: "red" +& block: n := n + 1; n
  [Posn(1, 2).color, Posn(1, 2).color]
  ~is ["red1", "red2"]

// Make sure static info flows through field and method
// references without `this.`
check:
  class Posn(x, y)
  class PosnUser(p :: Posn):
    method m():
      p.x + get().y
    method get() :: Posn:
      p
  PosnUser(Posn(1, 2)).m()
  ~is 3

block:
  class Posn(x, y):
    nonfinal
  class Posn3D(z :: Int):
    extends Posn
  check:
    Posn3D(1, 2, "x")
    ~raises "annotation"
  check:
    Posn3D("1", "2", 3)
    ~is Posn3D("1", "2", 3)

// refer to class as annotation for a field
check:
  class Posn(x, y)
  class Dir(loc :~ Posn, content :: List.of(Dir))
  Dir(Posn(0, 0), [Dir(Posn(1, 2), [])]).content[0].loc.x
  ~is 1

check:
  class Posn(x, y)
  class Dir(loc :~ Posn, content :: List.of(Dir)):
    method get() :: Dir: this
  Dir(Posn(0, 0), [Dir(Posn(1, 2), [])]).content[0].get().loc.x
  ~is 1

check:
  use_dynamic
  class CPosn(mutable x, y):
    private field c = "red"
    property | color: c
             | color := new_c: c := new_c
    property | is_red: c == "red"
    property me: this
    property | me2: this
             | me2 := other: "no"
  def p = CPosn(1, 2)
  [dynamic(p).x := 3,
   p.x,
   dynamic(p).color := "blue",
   p.color,
   p.is_red,
   p.me.color, p.me2.color]
  ~is [#void, 3, #void, "blue", #false, "blue", "blue"]

check:
  class CPosn(x, y):
    private field c = "red"
    property | color: c
             | color := new_c: c := new_c
    property me :: CPosn: this
    property | me2 :: CPosn: this
             | me2 := other: "no"
  def p = CPosn(1, 2)
  [p.color,
   p.me.color, p.me2.color]
  ~is ["red", "red", "red"]

check:
  ~eval
  use_static
  class CPosn(x, y):
    property | me2 :: CPosn: this
             | me2 := other: "no"
  (CPosn(1, 2).me2 := 10).x
  ~raises values("no such field or method", "static")
