#lang rhombus
import: "check.rhm" open

use_static

check:
  interface Shape:
    method area()
    method ten_area(): 10 * area()

  interface Polygon:
    extends Shape
    method sides()
    method has_corners(): #true

  interface Circle:
    extends Shape
    method has_sides(): #false

  class ApproxCircle():
    implements: Polygon Circle
    override area(): 33
    override sides(): 100

  def a = ApproxCircle()

  [a.area(),
   a.sides(),
   a.has_corners(),
   a.has_sides(),
   
   (a -: Polygon).has_corners(),
   (a -: Circle).has_sides(),

   (a -: Shape).area(),
   (a -: Polygon).area(),
   (a -: Circle).area(),

   a.ten_area(),

   Shape.area(a),
   Circle.area(a)]

  [33, 100, #true, #false,
   #true, #false,
   33, 33, 33,
   330,
   33, 33]

// conflict
check:
  ~eval_exn
  interface Shape:
    method draw(): "circle"
  interface Cowboy:
    method draw(): "bang"
  class LoneRanger():
    implements Shape
    implements Cowboy
  "method supplied by multiple superinterfaces"

// conflict resolved
check:
  interface Shape:
    method draw(): "circle"
  interface Cowboy:
    method draw(): "bang"
  class LoneRanger():
    implements Shape
    implements Cowboy
    override draw(): "bullseye"
  def l = LoneRanger()
  [l.draw(), (l -: Shape).draw(), (l -: Cowboy).draw()]
  ["bullseye", "bullseye", "bullseye"]

// diamond
check:
  interface Shape:
    abstract draw
  interface Cowboy:
    abstract draw
  class LoneRanger():
    implements Shape
    implements Cowboy
    override draw(): 10
  LoneRanger().draw()
  10

// diamond with extra methods
check:
  interface Shape:
    abstract draw
  interface Circle:
    extends Shape
    method cdraw(): draw() +& "_circle"
  interface Square:
    extends Shape
    method sdraw(): draw() +& "_square"
  class Squircle():
    implements Circle
    implements Square
    override draw(): "squircle"
  [Squircle().cdraw(),
   Squircle().sdraw()]
  ["squircle_circle",
   "squircle_square"]

// super call in interface
check:
  interface Shape:
    method draw(): "shape"
  interface Circle:
    extends Shape
    override draw(): "circle " +& super.draw()
  class Oval():
    implements Circle
  Oval().draw()
  "circle shape"

// private interface implementation
check:
  interface Adder:
    internal _Adder
    abstract total
  class Sum(x):
    private implements Adder
    private override total(): x
  def s = Sum(20)
  [s is_a Adder,
   s is_a _Adder,
   (s -: _Adder).total()]
  [#false, #true, 20]

check:
  interface Adder:
    abstract total
  class Sum(x):
    private implements Adder
    private override total(): x
  Sum(20) is_a Adder
  #false

check:
  ~eval_exn
  begin:
    interface Adder:
      abstract total
    class Sum(x):
      private implements Adder
      private override total(): x
    Sum(20).total
  "no such field"

check:
  ~eval_exn
  begin:
    use_static
    interface Adder:
      abstract total
    class Sum(x):
      private implements Adder
      private override total(): x
    Sum(20).total
  "no such public field or method"

// implement an interface both privately and publicly => public
check:
  interface Adder:
    abstract total
  class Sum(x):
    private implements Adder
    implements Adder
    override total(): x
  [Sum(20) is_a Adder,
   Sum(21).total()]
  [#true, 21]

// overlap of private and public is public
check:
  interface Stool:
    internal _Stool
    abstract legs
    abstract seat
  interface Cow:
    abstract legs
    abstract horns
  class MilkShed():
    private implements Stool
    implements Cow
    override legs(): 4
    override horns(): 2
    private override seat(): 1
  def m = MilkShed()
  check:
    ~exn
    (m -: Stool).seat()
    "Stool"
  [m is_a Stool,
   m is_a _Stool,
   m is_a Cow,
   m.legs(),
   m.horns(),
   (m -: _Stool).seat()]
  [#false, #true, #true,
   4, 2, 1]

check:
  interface I1: method m
  interface I2: abstract m
  interface I3: method m
  interface I4: abstract method m
  interface I5: method m()
  interface I6: abstract method m()
  interface I7: method m() :: Integer
  interface I8: abstract method m() :: Integer
  interface I9: method m(x, y) :: Integer
  interface IA: abstract method m(x, y) :: Integer
  interface IB: method m(x :: String, y :: Symbol) :: Integer
  interface IC: abstract method m(x :: String, y :: Symbol) :: Integer
  "ok"
  "ok"
  