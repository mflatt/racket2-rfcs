#lang rhombus/static

import:
  rhombus/draw
  pict:
    expose Pict
  lib("slideshow/main.rkt") as rkt
  lib("pict/main.rkt") as rkt_pict
  lib("slideshow/play.rkt") as rkt_play
  lib("racket/string.rkt")

export:
  Pict

  // flattens nested lists in arguments:
  slide

  // special values recognized by `slide`
  Pause
  Alts
  Animated

  // finds all picts tat `slide` would (including flattening lists,
  // and going into `alts`) to get the maximum pict width, then makes
  // all picts that wide; use this to align a subsequence within `slide`
  align

  // these flatten nested lists of mixtures of strings and picts
  // and convert only the strings, combining all with `beside`;
  // so, they work well with `@` notation
  t
  bold
  italic
  tt
  roman

  // `ly` variants are syntactic forms that `parameterize`
  // the argument expressions, so that `italic` can be nested in
  // `boldly` to get bold italic, etc.
  boldly
  italicly
  ttly
  romanly

  // like `above`, but with the current line separation
  lines

  // these flatten nested lists, so they work well with `@` notation;
  // unlike Racket slideshow, the default is that the result pict is
  // only as wide as needed, with the intent that `align` is used to
  // make blocks of paragraphs and bullets
  para
  item
  subitem

  table

  interactive

  start_at_recent_slide

// Rhombus should have a short way to write this, and one that
// gives current_font() the right static info
def current_font = Parameter.make(block:
                                    let init = rkt.#{current-main-font}()
                                    fun find_one(a, pred):
                                      match a
                                      | Pair(a, d): find_one(a, pred) || find_one(d, pred)
                                      | ~else: pred(a) && a
                                    draw.Font(~size: 32,
                                              ~name: find_one(init, fun (x): x is_a String),
                                              ~kind: find_one(init, fun (x): x is_a Symbol) || #'default),
                                  ~guard:
                                    block:
                                      fun current_font(font :: draw.Font):
                                        font
                                      current_font)


fun flatten_string(who, c, font) :~ Pict:
  match c
  | s :: String: pict.text(s, ~font: font)
  | p :: Pict: p
  | [c, ...]: Pict.from_handle(rkt.#{htl-append}(flatten_string(who, c, font).handle, ...))
  | ~else:
      error(who, "bad text content: " +& to_string(c, ~mode: #'expr))

fun t(~font: font :: draw.Font = current_font(),
      s, ...) :~ Pict:
  flatten_string(#'t, [s, ...], font)

fun current_font_as_bold():
   (current_font() :~ draw.Font) with (weight = #'bold)

fun current_font_as_italic():
   (current_font() :~ draw.Font) with (style = #'italic)

fun current_font_as_tt():
   (current_font() :~ draw.Font) with (kind = #'modern, name = #false)

fun current_font_as_roman():
   (current_font() :~ draw.Font) with (kind = #'roman, name = #false)

macro 'boldly($arg, ...)':
  '(parameterize { current_font: current_font_as_bold() }:
      t($arg, ...)) :~ Pict'

macro 'italicly($arg, ...)':
  '(parameterize { current_font: current_font_as_italic() }:
      t($arg, ...)) :~ Pict'

macro 'ttly($arg, ...)':
  '(parameterize { current_font: current_font_as_tt() }:
      t($arg, ...)) :~ Pict'

macro 'romanly($arg, ...)':
  '(parameterize { current_font: current_font_as_roman() }:
      t($arg, ...)) :~ Pict'

fun bold(a, ...) :~ Pict:
  boldly(a, ...)

fun italic(a, ...) :~ Pict:
  italicly(a, ...)

fun tt(a, ...) :~ Pict:
  ttly(a, ...)

fun roman(a, ...) :~ Pict:
  romanly(a, ...)

// ----------------------------------------

fun gap(): 24

class Pause()

class Alts(alts :~ List):
  opaque
  constructor (alt, ...):
    super([flatten_slide_content(#'Alts, alt),
           ...])

class Animated(proc,
               ~skip_first: skip_first = #false,
               ~skip_last: skip_last = #false):
  opaque
  method pict(n :: Real.in(0, 1)) :~ Pict:
    proc(rkt_play.#{fast-middle}(n))

class PrefixSize(w, h)

fun flatten_slide_content(who, c) :~ List:
  match c
  | [c, ...]: List.append(flatten_slide_content(who, c), ...)
  | p :: Pict: [p]
  | p :: satisfying(rkt_pict.#{pict?}): [Pict.from_handle(p)]
  | p :: Pause: [p]
  | Alts([]): []
  | p :: Alts: [p]
  | p :: Animated: [p]
  | ~else:
      error(who, "bad slide content: " +& to_string(c, ~mode: #'expr))

class Plan(procs :~ List, suffix :~ maybe(Pict))

fun slide(~title: title :: maybe(String || Pict) = #false,
          ~layout: layout :: matching(#'auto || #'center || #'top || #'tall) = #'auto,      
          content, ...):
  let contents = flatten_slide_content(#'slide, [content, ...])
  fun emit(p):
    rkt.slide(~title: title,
              ~layout: layout,
              & (if p | [Pict.handle(p)] | []))
  fun
  | combine(#false, other): other
  | combine(other, #false): other
  | combine(a, b): pict.above(~sep: gap(), a, b)                            
  fun pin_size(alt_p :~ Pict, w, h):
    let dw = math.max(0, (w - alt_p.width) / 2)
    alt_p.inset(dw, 0, dw, math.max(0, h - alt_p.height))
  fun show(v, x): println([v, x]); v
  // returns two values:
  //   a list of functions
  //   a initial pict or #f for empty
  fun render_plan(contents = contents, prefix = #false, static = #false):
    match contents
    | []:
        if static
        | prefix
        | Plan([fun (): emit(prefix)],
               prefix)
    | [p :: Pict, & contents]:
        render_plan(contents, combine(prefix, p), static)
    | [PrefixSize(w, h), & contents]:
        render_plan(contents, prefix && pin_size(prefix, w, h), static)
    | [_ :: Pause, & contents]:
        if static
        | let suffix = render_plan(contents, prefix, #true)
          suffix && Pict.ghost(suffix)
        | let Plan(rest, suffix) = render_plan(contents, prefix, #false)
          let ghost_suffix = suffix && Pict.ghost(suffix)
          Plan([fun ():
                  match [prefix, suffix]
                  | [#false, #false]: emit(#false)
                  | [#false, _]: emit(ghost_suffix)
                  | [_, ghost_suffix :: Pict]:
                      emit(pin_size(prefix, ghost_suffix.width, ghost_suffix.height)),
                & rest],
               ghost_suffix)
    | [Alts(alts), & contents]:
        let suffix = render_plan(contents, #false, #true)
        let [alt, ...] = alts
        // get pict to determine the size of each alternative:
        let alt_ps = [render_plan(alt, #false, #true), ...]
        let (w, h) = (for values(w = #false, h = #false) (alt_p: alt_ps):
                        match alt_p
                        | alt_p :: Pict:
                            values(math.max(w || 0, alt_p.width),
                                   math.max(h || 0, alt_p.height))
                        | ~else:
                            values(w, h))
        cond
        | !w:
              // no picts from any alt, so suffix or plan is unchanged
              if static
              | suffix
              | render_plan(contents, prefix, #false)
        | ~else:
            // drop alts that do not contribute
            let alts = (for List (alt: alts,
                                  alt_p: alt_ps):
                          keep_when alt_p
                          alt)
            if static
            | combine(prefix, combine(pin_size(alt_ps[0], w, h), suffix))
            | let [alt0 :~ List, ...] = alts.drop_right(1)
              let alt_last :~ List = alts[alts.length() - 1]
              // rendering instruction to grow the prefix, if needed
              let prefix_size = (match prefix
                                 | prefix :: Pict: PrefixSize(math.max(prefix.width, w),
                                                              prefix.height + gap() + h)
                                 | ~else: PrefixSize(w, h))
              let alt_rest = [prefix_size, & (if suffix | [suffix] | [])]
              let [Plan([proc0, ...], _), ...] = [render_plan(alt0 ++ alt_rest, prefix, #false),
                                                  ...]
              let Plan(procs, new_suffix) = render_plan(alt_last ++ [prefix_size] ++ contents, prefix, #false)
              Plan([proc0, ..., ..., &procs],
                   new_suffix)
    | [content :: Animated, & contents]:
        let first_p = content.pict(0)          
        if static
        | render_plan(contents, combine(prefix, first_p), #true)
        | let last_p = content.pict(1)
          let suffix = render_plan(contents, #false, #true)
          let Plan(rest, full_suffix) = render_plan(contents, combine(prefix, last_p), #false)
          Plan([fun ():
                  rkt_play.#{play-n}(~title: title,
                                     ~layout: layout,
                                     #{#:skip-first?}: content.skip_first,
                                     #{#:skip-last?}: content.skip_last,
                                     fun (n):
                                       Pict.handle(combine(prefix,
                                                           combine(content.pict(n),
                                                                   suffix)))),
                & rest],
               combine(combine(prefix, first_p), suffix))
    | [content, & _]:
        error(#'slide, "unrecognized slide content: " +& to_string(content, ~mode: #'expr))
  let Plan(procs, _) = render_plan(contents, #false, #false)
  for (proc: procs):
    proc()

// flattens, but does not convert
fun align(~align: dir :: matching(#'left || #'center || #'right) = #'left,
          content, ...):
  let cs = flatten_slide_content(#'align, [content, ...])
  let width:
    recur loop (cs :~ List = cs):
      for values(w = 0) (c: cs):
        match c
        | p :: Pict: math.max(w, p.width)
        | a :: Alts:
            for values(w = 0) (elem: a.alts):
              math.max(w, loop(elem))
        | ~else: w
  recur loop (cs :~ List = cs):
    for List (c: cs):
        match c
        | p :: Pict:
            match dir
            | #'left: p.inset(0, 0, width - p.width, 0)
            | #'center: p.inset((width - p.width) / 2, 0)
            | #'right: p.inset(width - p.width, 0, 0, 0)
        | a :: Alts:
            Alts(for List (elem: a.alts):
                   loop(elem))
        | ~else: c

// ----------------------------------------

fun lines(~align: align :: matching(#'left || #'center || #'right) = #'left,
          p :: Pict, ...) :~ Pict:
  pict.above(~sep: rkt.#{current-line-sep}(),
             ~align: align,
             p, ...)

def current_para_width = rkt.#{current-para-width}

fun flatten_para_content(who, c) :~ List:
  match c
  | s :: String:
      let PairList[str, ...] = string.#{string-split}(s)
      [rkt.para(#{#:fill?}: #false, str), ...]
  | p :: Pict: [p.handle]
  | [c, ...]: List.append(flatten_para_content(who, c), ...)
  | ~else:
      error(who, "bad paragraph content: " +& to_string(c, ~mode: #'expr))


fun para(~width: width = current_para_width(),
         ~at_max: at_max = #false,
         content, ...) :~ Pict:
  Pict.from_handle(rkt.para(#{#:fill?}: at_max,
                            ~width: width,
                            & flatten_para_content(#'slide, [content, ...])))

fun item(~width: width = current_para_width(),
         ~at_max: at_max = #false,
         content, ...) :~ Pict:
  Pict.from_handle(rkt.item(#{#:fill?}: at_max,
                            ~width: width,
                            & flatten_para_content(#'slide, [content, ...])))

fun subitem(~width: width = current_para_width(),
            ~at_max: at_max = #false,
            content, ...) :~ Pict:
  Pict.from_handle(rkt.subitem(#{#:fill?}: at_max,
                               ~width: width,
                               & flatten_para_content(#'slide, [content, ...])))

// ----------------------------------------

fun table(rows :: List.of(List)) :~ Pict:
  let [[elem, ...], ...] = rows
  fun convert(elem):
    match elem
    | elem :: String: t(elem).handle
    | elem :: Pict: elem.handle
  Pict.from_handle(rkt.table(rows[0].length(),
                             PairList[convert(elem), ..., ...],
                             rkt.#{ltl-superimpose},
                             rkt.#{ltl-superimpose},
                             gap(),
                             rkt.#{current-line-sep}()))

// ----------------------------------------

fun interactive(p :: Pict, callback :: Function.of_arity(1)) :~ Pict:
  Pict.from_handle(rkt.interactive(p.handle, callback))

fun start_at_recent_slide():
  rkt.#{start-at-recent-slide}()

slide(pict.text("hello"),
      Pause(),
      Alts(pict.text("first"),
           pict.text("second").scale(2)),
      Pause(),
      Animated(fun (n): pict.text("flower").scale(n+1)),
      Pause(),
      pict.text("done!"))


           