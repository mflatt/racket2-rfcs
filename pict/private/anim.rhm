#lang rhombus/static/and_meta

import:
  rhombus/draw:
    expose Color
  "static.rhm" as pict:
    expose:
      Pict
  "static.rhm"!private:
    expose:
      StaticPict

export:
  AnimPict
  sequential
  concurrent
  transition

annot.macro 'SequentialJoin':
  annot_meta.pack_predicate('is_seq_join', '()')
fun is_seq_join(v):
  match v
  | #'step || #'splice: #true
  | ~else: #false

class AnimPict(private get_pict,
               _epoch_durations :~ List.of(Real),
               _start_epoch :~ Int, // index into `_epoch_durations` for epoch 0
               before :~ StaticPict,
               after :~ StaticPict,
               _splicing :~ matching(#'both || #'after || #'before || #'none)):
  extends Pict
  internal _AnimPict

  override property width: before.width
  override property height: before.height
  override property ascent: before.ascent
  override property descent: before.descent

  override property epochs:
    math.max(0, _epoch_durations.length() - _start_epoch)
  override method epoch_duration(i):
    let i = i + _start_epoch
    cond
    | i < 0: 0
    | ~else:
        if i >= _epoch_durations.length()
        | 0
        | _epoch_durations[i]

  override property splices_before: _splicing == #'both || _splicing == #'before
  override property splices_after: _splicing == #'both || _splicing == #'after

  override property min_width: math.min(before.width, after.width)
  override property min_height: math.min(before.height, after.height)
  override property min_ascent: math.min(before.ascent, after.ascent)
  override property min_descent: math.min(before.descent, after.descent)

  override property max_width: math.max(before.width, after.width)
  override property max_height: math.max(before.height, after.height)
  override property max_ascent: math.max(before.ascent, after.ascent)
  override property max_descent: math.max(before.descent, after.descent)

  constructor
  | (p :: Pict):
      super()(fun (epoch, n, instances):
                p,
              [0],
              0,
              p, p,
              #'none)
  | (proc :: Function.of_arity(1),
     ~duration: duration :: PosReal):
      let before :: Pict = proc(0)
      let after :: Pict = proc(1)
      super()(fun (epoch, n, instances):              
                cond
                | epoch < 0: before
                | epoch >= 1 || n >= 1: after
                | n <= 0: before
                | ~else: proc(n),
              [duration],
              0,
              before,
              after,
              #'none)
  
  override method
  | snapshot() :~ Pict: snapshot(0, 0, MutableMap{})
  | snapshot(epoch :: Int, n :: Real.in(0, 1), instances :~ MutableMap) :~ Pict:
      let key = [this, epoch, n]
      instances.get(key, #false)
        || (block:
              let p = get_pict(epoch, n, instances)
              instances[key] := p
              p)

  override method
  | inset(amt :: Real) :~ AnimPict:
      inset(amt, amt, amt, amt)
  | inset(horiz :: Real, vert :: Real) :~ AnimPict:
      inset(horiz, vert, horiz, vert)
  | inset(left :: Real, top :: Real, right :: Real, bottom :: Real) :~ AnimPict:
      anim_pict_like(this,
                     ~get_pict: fun (epoch, n, instances):
                                  snapshot(epoch, n, instances).inset(left, top, right, bottom),
                     ~before: before.inset(left, top, right, bottom),
                     ~after: after.inset(left, top, right, bottom))

  override method timecrop(~keep: keep :: maybe(matching(#'before || #'after)) = #false) :~ AnimPict:
    anim_pict_like(this,
                   ~get_pict: fun (epoch, n, instances):
                                let p = snapshot(epoch, n, instances)
                                cond
                                | (epoch < 0) && keep != #'before:
                                    p.ghost()
                                | (epoch >= epochs) && keep != #'after:
                                    p.ghost()
                                | ~else:
                                    p)

  override method splicing(dir :: maybe(matching(#'before || #'after || #'both || #'none)) = #false) :~ AnimPict:
    anim_pict_like(this,
                   ~splicing: dir)

  override method launder() :~ AnimPict:
    anim_pict_like(this,
                   ~get_pict: fun (epoch, n, instances):
                                snapshot(epoch, n, instances).launder())
    
  override method ghost() :~ AnimPict:
    anim_pict_like(this,
                   ~get_pict: fun (epoch, n, instances):
                                snapshot(epoch, n, instances).ghost())
    
  override method refocus(to_p :: Pict) :~ AnimPict:
    this
    
  override method lift(amt :: Real) :~ Pict:
    anim_pict_like(this,
                   ~get_pict: fun (epoch, n, instances):
                                snapshot(epoch, n, instances).lift(amt),
                   ~before: before.lift(amt),
                   ~after: after.lift(amt))

  override method
  | scale(amt :: Real) :~ Pict:
      anim_pict_like(this,
                     ~get_pict: fun (epoch, n, instances):
                                  snapshot(epoch, n, instances).scale(amt),
                     ~before: before.scale(amt),
                     ~after: after.scale(amt))
  | scale(h_amt :: Real, v_amt :: Real) :~ Pict:
      anim_pict_like(this,
                     ~get_pict: fun (epoch, n, instances):
                                  snapshot(epoch, n, instances).scale(h_amt, v_amt),
                     ~before: before.scale(h_amt, v_amt),
                     ~after: after.scale(h_amt, v_amt))

  override method rotate(radians :: Real) :~ Pict:
    anim_pict_like(this,
                   ~get_pict: fun (epoch, n, instances):
                                snapshot(epoch, n, instances).scale(radians),
                   ~before: before.rotate(radians),
                   ~after: after.rotate(radians))

  override method colorize(c :: (Color || String)) :~ Pict:
    anim_pict_like(this,
                   ~get_pict: fun (epoch, n, instances):
                                snapshot(epoch, n, instances).colorize(c))

fun anim_pict(get_pict, epoch_durations, start_epoch, before, after, splicing) :~ AnimPict:
  _AnimPict()(get_pict, epoch_durations, start_epoch, before, after, splicing)

fun anim_pict_like(this :~ _AnimPict,
                   ~get_pict: get_pict = this.get_pict,
                   ~epoch_durations: epoch_durations = this._epoch_durations,
                   ~start_epoch: start_epoch = this._start_epoch,
                   ~before: before = this.before,
                   ~after: after = this.after,
                   ~splicing: splicing = this._splicing) :~ AnimPict:
  _AnimPict()(get_pict, epoch_durations, start_epoch, before, after, splicing)

fun merge_epochs([p :~ AnimPict, ...]):
  let min_epoch = math.min(math.min(0, -p._start_epoch), ...)
  let max_epoch = math.max(math.max(0, p.epochs - 1), ...)
  let num_epochs = max_epoch + 1 - min_epoch
  let all_epochs:
    for List (i: min_epoch .. min_epoch + num_epochs):
      math.max(p.epoch_duration(i), ...)
  let splicing:
    for values (splicing = #'both) (p: [p, ...]):
      let splicing = (if !p.splices_before
                      | match splicing
                        | #'both: #'after
                        | #'before: #'none
                        | ~else: splicing
                      | splicing)
      let splicing = (if p.epochs == num_epochs && !p.splices_after
                      | match splicing
                        | #'both: #'before
                        | #'after: #'none
                        | ~else: splicing
                      | splicing)
      splicing
  values (-min_epoch, all_epochs, splicing)

fun sequential(~join: mode :: SequentialJoin = #'step,
               p :: Pict, ...) :~ List.of(AnimPict):
  let (ps, starts) = make_sequential(for List (p: [p, ...]):
                                       if p is_a StaticPict
                                       | AnimPict(p)
                                       | p,
                                     ~join: mode)
  ps

fun make_sequential(ps :~ List.of(AnimPict),
                    ~join: mode) :~ values(List.of(AnimPict),
                                           List.of(Int)):
  fun later(p :~ AnimPict, dt):
    if dt == 0
    | p
    | let _AnimPict(get, epochs, start_epoch, before, after, splicing) = p
      anim_pict(fun (epoch, n, instances): get(epoch - dt, n, instances),
                epochs,
                start_epoch - dt,
                before, after,
                splicing)
  fun refocus(p :~ AnimPict, at_epoch, total, used):
    let index = at_epoch - p._start_epoch
    cond
    | index < 0 || index >= p._epoch_durations.length():
        p
    | total == p._epoch_durations[index]:
        p
    | ~else:
        let orig = p._epoch_durations[index]
        let ratio = orig / total
        let begin_ratio = used / total
        let _AnimPict(get, epochs, start_epoch, before, after, splicing) = p
        anim_pict(fun (epoch, n, instances):
                    cond
                    | epoch != at_epoch: get(epoch, n, instances)
                    | n < begin_ratio: get(epoch - 1, 1, instances)
                    | n >= begin_ratio + ratio: get(epoch, 1, instances)
                    | ~else: get(epoch, (n - begin_ratio) / ratio, instances),
                  epochs.delete(index).insert(index, total),
                  start_epoch,
                  before, after,
                  splicing)
  fun adjust_offset(p :~ AnimPict, offset, can_splice):
    if can_splice && (p._splicing == #'before || p._splicing == #'both)
    | offset - 1
    | offset
  let durations = MutableMap{}
  fun bump_durations(p :~ AnimPict, offset, durations :~ MutableMap):
    let start_index = -p._start_epoch
    let end_index = (p.epochs - p._start_epoch) - 1
    fun bump(index, offset):
      when index >= 0 && index < p._epoch_durations.length()
      | durations[offset] := durations.get(offset, 0) + p._epoch_durations[index]
    bump(start_index, offset)
    when start_index != end_index
    | bump(end_index, offset + p.epochs - 1)
    let next_splice = mode == #'splice || p._splicing == #'after || (p._splicing == #'both)
    values(offset + math.max(0, p.epochs - (if next_splice | 1 | 0)),
           !next_splice)
  for values(offset = 0, splice = #false) (p: ps):
    bump_durations(p, adjust_offset(p, offset, splice), durations)
  let used_durations = MutableMap{}
  let (accum, starts_accum, t, _):
    for values(accum :~ List = [], starts_accum :~ List = [], offset = 0, splice = #false):          
      each p: ps
      let offset = adjust_offset(p, offset, splice)
      let start_total = durations.get(offset, 0)
      let start_used = used_durations.get(offset, 0)
      let new_p:
        let new_p = refocus(p, 0, start_total, start_used)
        if p.epochs <= 1
        | new_p
        | let end = offset + p.epochs - 1
          let end_total = durations.get(end, 0)
          let end_used = used_durations.get(end, 0)
          refocus(new_p, p.epochs - 1, end_total, end_used)          
      let (new_offset, new_splice) = bump_durations(p, offset, used_durations)
      values(accum.add(later(new_p, offset)),
             starts_accum.add(offset),
             new_offset,
             new_splice)
  values(accum, starts_accum)

fun concurrent(~talign: align :: pict.TimeAlignment = #'center,
               p :: Pict, ...) :~ List.of(Pict):
  let ps = [p, ...]
  if (for all (p: ps):
        p is_a StaticPict)
  | ps
  | make_concurrent(for List (p: ps):
                      if p is_a StaticPict
                      | AnimPict(p)
                      | p,
                    ~talign: align)

fun make_concurrent(ps :~ List.of(AnimPict),
                    ~talign: align) :~ List.of(AnimPict):
  match ps
  | []: []
  | [p, ...]:
      let (total_start_epoch, total_epoch_durations :~ List, total_splicing) = merge_epochs([p, ...])
      for List (p :~ _AnimPict: ps):
        let get = p.get_pict
        anim_pict_like(p,
                       ~get_pict:
                         fun (epoch, n, instances):
                           let duration = p.epoch_duration(epoch)
                           get(epoch,
                               if duration .= 0
                               | n
                               | let e = epoch - total_start_epoch
                                 let ratio = duration / total_epoch_durations[e]
                                 match align
                                 | #'early: (if n < ratio | n / ratio | 1)
                                 | #'late: (if n < 1 - ratio | 0 | (n - ratio) / ratio)
                                 | #'center: cond
                                             | n < (1 - ratio) / 2: 0
                                             | n >= 1 - ((1 - ratio) / 2): 1
                                             | ~else: (n - ((1 - ratio) / 2)) / ratio
                                 | #'stretch: if ratio .= 0
                                              | 1
                                              | n / ratio,
                               instances),
                       ~epoch_durations:
                         for List (i: 0..p._epoch_durations.length()):
                           total_epoch_durations[-p._start_epoch + total_start_epoch])

private.set_convert(
  fun (ps :~ List, talign, combine):
    let [p :~ AnimPict, ...]:
      make_concurrent(for List (p: ps):
                        if p is_a StaticPict
                        | AnimPict(p)
                        | p,
                      ~talign: talign)
    let (total_start_epoch, total_epoch_durations :~ List, total_splicing) = merge_epochs([p, ...])
    anim_pict(fun (epoch, n, instances):
                combine([p.snapshot(epoch, n, instances), ...]),
              total_epoch_durations,
              total_start_epoch,
              combine([_AnimPict.before(p), ...]),
              combine([_AnimPict.after(p), ...]),
              total_splicing)
)

fun transition(~valign: valign :: pict.VerticalAlignment = #'center,
               ~halign: halign :: pict.HorizontalAlignment = #'center,
               ~join: join :: SequentialJoin = #'step,
               p :: Pict, ...) :~ Pict:
  let ps = (for List (p: [p, ...]):
              if p is_a AnimPict
              | p
              | AnimPict(p))
  let (ps, starts) = make_sequential(ps, ~join: join)
  let (total_start_epoch, total_epoch_durations :~ List, total_splicing) = merge_epochs(ps)
  let max_epoch = total_epoch_durations.length() - total_start_epoch
  anim_pict(fun (epoch, n, instances):
              cond
              | epoch < 0:
                  ps[0].snapshot(epoch, n, instances)
              | epoch > max_epoch:
                  ps[ps.length() - 1].snapshot(epoch, n, instances)
              | ~else:
                  let ps:
                    for List (p: ps, start: starts):
                      keep_when: epoch >= start && epoch < p.epochs
                      p
                  pict.overlay(~valign: valign,
                               ~halign: halign,
                               & ps).snapshot(epoch, n, instances),
            total_epoch_durations,
            total_start_epoch,
            ps[0].before,
            ps[ps.length()-1].after,
            total_splicing)
  