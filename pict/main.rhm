#lang rhombus/static/and_meta

import:
  rhombus/draw:
    expose Color
  lib("pict/main.rkt") as rkt:
    expose #{pict?}
  lib("pict/balloon2.rkt") as bln

export:
  Color
  HorizontalAlignment
  VerticalAlignment
  
  Pict

  text
  
  beside
  above
  overlay

  blank
  line
  rectangle
  square
  ellipse
  circle
  bitmap

  Find
  connect

  balloon

class Pict(private _handle):
  opaque
  internal _Pict
  constructor (): _Pict(rkt.blank())
  export from_handle

  property handle: _handle
  property width: rkt.#{pict-width}(_handle)
  property height: rkt.#{pict-height}(_handle)
  property ascent: rkt.#{pict-ascent}(_handle)
  property descent: rkt.#{pict-descent}(_handle)

  method launder() :~ Pict:
    _Pict(rkt.launder(handle))

  method ghost() :~ Pict:
    _Pict(rkt.ghost(handle))

  method refocus(to_p :: Pict) :~ Pict:
    _Pict(rkt.refocus(handle, to_p.handle))

  method
  | inset(amt :: Real) :~ Pict:
      _Pict(rkt.inset(handle, amt))
  | inset(h_amt :: Real, v_amt :: Real) :~ Pict:
      _Pict(rkt.inset(handle, h_amt, v_amt))
  | inset(left_amt :: Real, top_amt :: Real,
          right_amt :: Real, bottom_amt :: Real) :~ Pict:
      _Pict(rkt.inset(handle, left_amt, top_amt, right_amt, bottom_amt))

  method lift(amt :: Real) :~ Pict:
    _Pict(rkt.#{lift-bottom-relative-to-baseline}(handle, amt))

  method
  | scale(amt :: Real) :~ Pict:
      let p = rkt.scale(handle, amt)
      let p = if amt .= 0 | rkt.ghost(p) | p
      _Pict(p)
  | scale(h_amt :: Real, v_amt :: Real) :~ Pict:
      let p = rkt.scale(handle, h_amt, v_amt)
      let p = if h_amt .= 0 || v_amt .= 0 | rkt.ghost(p) | p
      _Pict(p)

  method rotate(radians :: Real) :~ Pict:
    _Pict(rkt.rotate(handle, radians))

  method colorize(c :: (Color || String)) :~ Pict:
    _Pict(rkt.colorize(handle, as_color(c)))

fun from_handle(p :: satisfying(#{pict?})) :~ Pict:
  _Pict(p)

def default_font = draw.Font()

annot.macro 'HorizontalAlignment':
  annot_meta.pack_predicate('is_horiz_aign', '()')
fun is_horiz_aign(v):
  match v
  | #'left || #'center || #'right: #true
  | ~else: #false

annot.macro 'VerticalAlignment':
  annot_meta.pack_predicate('is_vert_aign', '()')
fun is_vert_aign(v):
  match v
  | #'top || #'topline || #'center || #'baseline || #'bottom: #true
  | ~else: #false

fun beside(~sep: sep = 0,
           ~align: align :: VerticalAlignment = #'center,
           p :: Pict, ...) :~ Pict:
  match align
  | #'top: _Pict(rkt.#{ht-append}(sep, p.handle, ...))
  | #'topline: _Pict(rkt.#{htl-append}(sep, p.handle, ...))
  | #'center: _Pict(rkt.#{hc-append}(sep, p.handle, ...))
  | #'baseline: _Pict(rkt.#{hbl-append}(sep, p.handle, ...))
  | #'bottom: _Pict(rkt.#{hb-append}(sep, p.handle, ...))

fun above(~sep: sep = 0,
          ~align: align :: HorizontalAlignment = #'center,
          p :: Pict, ...) :~ Pict:
  match align
  | #'left: _Pict(rkt.#{vl-append}(sep, p.handle, ...))
  | #'center: _Pict(rkt.#{vc-append}(sep, p.handle, ...))
  | #'right: _Pict(rkt.#{vr-append}(sep, p.handle, ...))

fun overlay(~halign: halign :: HorizontalAlignment = #'center,
            ~valign: valign :: VerticalAlignment = #'center,
            p :: Pict, ...) :~ Pict:
  let [p, ...] = [p.handle, ...]
  _Pict(
    match halign
    | #'left:
        match valign:
        | #'top: rkt.#{lt-superimpose}(p, ...)
        | #'topline: rkt.#{ltl-superimpose}(p, ...)
        | #'center: rkt.#{lc-superimpose}(p, ...)
        | #'baseline: rkt.#{lbl-superimpose}(p, ...)
        | #'bottom: rkt.#{lb-superimpose}(p, ...)
    | #'center:
        match valign:
        | #'top: rkt.#{ct-superimpose}(p, ...)
        | #'topline: rkt.#{ctl-superimpose}(p, ...)
        | #'center: rkt.#{cc-superimpose}(p, ...)
        | #'baseline: rkt.#{cbl-superimpose}(p, ...)
        | #'bottom: rkt.#{cb-superimpose}(p, ...)
    | #'right:
        match valign:
        | #'top: rkt.#{rt-superimpose}(p, ...)
        | #'topline: rkt.#{rtl-superimpose}(p, ...)
        | #'center: rkt.#{rc-superimpose}(p, ...)
        | #'baseline: rkt.#{rbl-superimpose}(p, ...)
        | #'bottom: rkt.#{rb-superimpose}(p, ...)
  )

fun text(content :: String,
         ~font: font :: draw.Font = default_font) :~ Pict:
  _Pict(rkt.text(content, font.handle))

fun
| blank() :~ Pict: _Pict(rkt.blank())
| blank(size :: Real) :~ Pict: _Pict(rkt.blank(size))
| blank(width :: Real, height :: Real) :~ Pict: _Pict(rkt.blank(width, height))

fun line(~dx: dx :: Real = 0,
         ~dy: dy :: Real = 0,
         ~color: color :: Color || String || matching(#'inherit) = #'inherit,
         ~width: width :: Real || matching(#'inherit) = #'inherit) :~ Pict:
  def ln:
    cond
    | dx == 0: if dy == 0
               | rkt.blank()
               | rkt.vline(0, dy)
    | dy == 0: rkt.hline(dx, 0)
    | ~else:
        rkt.dc(fun (dc_handle, ddx, ddy):
                 def dc = draw.DC.from_handle(dc_handle)
                 dc.line([ddx, ddy], [ddx + dx, ddy + dy]))
  def cln:
    if color != #'inherit
    | rkt.colorize(ln, color)
    | ln
  _Pict(if width != #'inherit
        | rkt.linewidth(width, cln)
        | cln)

fun as_color(color):
  match color
  | #'inherit: #false
  | s :: String: s
  | c :: Color: c.handle

fun as_width(w):
  match w
  | #'inherit: #false
  | ~else: w

fun rectangle(~around: around :: maybe(Pict) = #false,
              width :: Real: if around | Pict.width(around) | 32,
              height :: Real: if around | Pict.height(around) | 32,
              ~line: line :: maybe(Color || String || matching(#'inherit)) = #'inherit,
              ~fill: fill :: maybe(Color || String || matching(#'inherit)) = #false,
              ~line_width: line_width :: Real || matching(#'inherit) = #'inherit) :~ Pict:
  def r:
    cond
    | fill:
        rkt.#{filled-rectangle}(width,
                                height,
                                #{#:color}: as_color(fill),
                                #{#:draw-border?}: line,
                                #{#:border-color}: line && as_color(line),
                                #{#:border-width}: as_width(line_width))
    | line:
        rkt.#{rectangle}(width,
                         height,
                         #{#:border-color}: as_color(line),
                         #{#:border-width}: as_width(line_width))
    | ~else:
        rkt.blank(width,
                  height)
  _Pict(if around
        | rkt.#{cc-superimpose}(r, Pict.handle(around))
        | r)

fun square(~around: around :: maybe(Pict) = #false,
           size :: Real: if around | math.max(Pict.width(around), Pict.height(around)) | 32,
           ~line: line :: maybe(Color || String || matching(#'inherit)) = #'inherit,
           ~fill: fill :: maybe(Color || String || matching(#'inherit)) = #false,
           ~line_width: line_width :: Real || matching(#'inherit) = #'inherit) :~ Pict:
  rectangle(~around: around,
            size, size,
            ~line: line,
            ~fill: fill,
            ~line_width: line_width)

fun ellipse(~around: around :: maybe(Pict) = #false,
            width :: Real: if around | Pict.width(around) | 32,
            height :: Real: if around | Pict.height(around) | 32,
            ~line: line :: maybe(Color || String || matching(#'inherit)) = #'inherit,
            ~fill: fill :: maybe(Color || String || matching(#'inherit)) = #false,
            ~line_width: line_width :: Real || matching(#'inherit) = #'inherit) :~ Pict:
  def r:
    cond
    | fill:
        rkt.#{filled-ellipse}(width,
                              height,
                              #{#:color}: as_color(fill),
                              #{#:draw-border?}: line,
                              #{#:border-color}: line && as_color(line),
                              #{#:border-width}: as_width(line_width))
    | line:
        rkt.#{ellipse}(width,
                       height,
                       #{#:border-color}: as_color(line),
                       #{#:border-width}: as_width(line_width))
    | ~else:
        rkt.blank(width,
                  height)
  _Pict(if around
        | rkt.#{cc-superimpose}(r, Pict.handle(around))
        | r)

fun circle(~around: around :: maybe(Pict) = #false,
           size :: Real: if around | math.max(Pict.width(around), Pict.height(around)) | 32,
           ~line: line :: maybe(Color || String || matching(#'inherit)) = #'inherit,
           ~fill: fill :: maybe(Color || String || matching(#'inherit)) = #false,
           ~line_width: line_width :: Real || matching(#'inherit) = #'inherit) :~ Pict:
  ellipse(~around: around,
          size, size,
          ~line: line,
          ~fill: fill,
          ~line_width: line_width)

fun bitmap(path :: Path || String) :~ Pict:
  _Pict(rkt.bitmap(path))

// ------------------------------------------------------------

class Find(private q, private find):
  internal _Find

  constructor(dx :: Real, dy :: Real):
    _Find(#false, fun (p, q): values(dx, dy))

  implements Printable
  override describe(mode, recur):
    "Pict(....)"

  method in(p :: Pict):
    find(p.handle, q && Pict.handle(q))

  export:
    center
    left
    right
    top
    topline
    baseline
    bottom
    left_top
    left_topline
    left_center
    left_baseline
    left_bottom
    center_top
    center_topline
    center_center
    center_baseline
    center_bottom
    right_top
    right_topline
    right_center
    right_baseline
    right_bottom

fun offset(proc, dx, dy):
  if dx == 0 && dy == 0
  | proc
  | fun (p, q):
      let (x, y) = proc(p, q)
      values(x + dx, y + dy)

fun center(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{cc-find}, dx, dy))
fun left(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{lc-find}, dx, dy))
fun right(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{rc-find}, dx, dy))
fun top(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{ct-find}, dx, dy))
fun topline(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{ct-find}, dx, dy))
fun baseline(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{cb-find}, dx, dy))
fun bottom(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{cb-find}, dx, dy))
  
fun left_top(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{lt-find}, dx, dy))
fun left_topline(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{ltl-find}, dx, dy))
fun left_center(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{lc-find}, dx, dy))
fun left_baseline(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{lbl-find}, dx, dy))
fun left_bottom(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{lb-find}, dx, dy))

fun center_top(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{ct-find}, dx, dy))
fun center_topline(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{ctl-find}, dx, dy))
fun center_center(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{cc-find}, dx, dy))
fun center_baseline(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{cbl-find}, dx, dy))
fun center_bottom(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{cb-find}, dx, dy))

fun right_top(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{rt-find}, dx, dy))
fun right_topline(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{rtl-find}, dx, dy))
fun right_center(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{rc-find}, dx, dy))
fun right_baseline(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{rbl-find}, dx, dy))
fun right_bottom(q :: Pict, ~dx: dx = 0, ~dy: dy = 0) :~ Find:
  _Find(q, offset(rkt.#{rb-find}, dx, dy))

fun connect(p :: Pict,
            from :: Find,
            to :: Find,
            ~style: style :: matching(#'line || #'arrow || #'arrows) = #'line,
            ~color: color :: Color || String || matching(#'inherit) = #'inherit,
            ~width: width :: Real || matching(#'inherit) = #'inherit,
            ~under: under = #false,
            ~arrow_size: arrow_size :: Real = 16,
            ~arrow_solid: solid = #true,
            ~arrow_hidden: hidden = #false,
            ~start_angle: start_angle :: maybe(Real) = #false,
            ~start_pull: start_pull :: maybe(Real) = #false,
            ~end_angle: end_angle :: maybe(Real) = #false,
            ~end_pull: end_pull :: maybe(Real) = #false,
            ~label: label :: maybe(Pict) = #false,
            ~label_dx: label_dx :: Real = 0,
            ~label_dy: label_dy :: Real = 0) :~ Pict:
  let (from_x, from_y) = from.in(p)
  let (to_x, to_y) = to.in(p)
  let (proc, [pre, ...], kw_args):
    match style
    | #'line: values(rkt.#{pin-line}, [], {})
    | #'arrow: values(rkt.#{pin-arrow-line},
                      [arrow_size],
                      { #'#{#:solid?}: solid, #'#{#:hide-arrowhead?}: hidden })
    | #'arrows: values(rkt.#{pin-arrows-line},
                       [arrow_size],
                       { #'#{#:solid?}: solid, #'#{#:hide-arrowhead?}: hidden })
  _Pict(proc(pre, ...,
             p.handle,
             p.handle, fun (p, q): values(from_x, from_y),
             p.handle, fun (p, q): values(to_x, to_y),
             #{#:start-angle}: start_angle,
             #{#:start-pull}: start_pull,    
             #{#:end-angle}: end_angle,
             #{#:end-pull}: end_pull,
             #{#:line-width}: as_width(width),
             #{#:color}: as_color(color),
             #{#:under?}: under,
             #{#:label}: label && Pict.handle(label),
             #{#:x-adjust-label}: label_dx,
             #{#:y-adjust-label}: label_dy,
             ~& kw_args))

// ------------------------------------------------------------

fun balloon(p :: Pict,
            at :: Find,
            content :: Pict,
            ~spike: spike :: matching(#'n || #'ne || #'e || #'se || #'s || #'sw || #'w || #'nw),
            ~margin: margin :: maybe(Real) = #false,
            ~hmargin: hmargin :: Real = margin || bln.#{current-balloon-x-margin}(),
            ~vmargin: vmargin :: Real = margin || bln.#{current-balloon-y-margin}(),
            ~corner_radius: corner_radius :: Real = 10,
            ~spike_radius: spike_radius :: Real = corner_radius,
            ~dx: dx :: Real = bln.#{spike->dx}(spike),
            ~dy: dy :: Real = bln.#{spike->dy}(spike),
            ~sprout: sprout :: Real = 0.5,
            ~thought: thought = #false,
            ~color: color :: maybe(Color || String) = #false,
            ~line_color: line_color :: maybe(Color || String) = #false,
            ~line_width: line_width :: Real = 0) :~ Pict:
  let (at_x, at_y) = at.in(p)
  _Pict(
    bln.#{pin-balloon}(p.handle,
                       p.handle, fun (p, q): values(at_x, at_y),
                       content.handle,
                       ~spike: spike,
                       #{#:x-margin}: hmargin,
                       #{#:y-margin}: vmargin,
                       #{#:corner-radius}: corner_radius,
                       #{#:spike-radius}: spike_radius,
                       ~dx: dx,
                       ~dy: dy,
                       ~sprout: sprout,
                       #{#:thought?}: thought,
                       ~color: (color && as_color(color)) || bln.#{current-balloon-color}(),
                       #{#:line-color}: line_color,
                       #{#:line-width}: line_width)
  )
