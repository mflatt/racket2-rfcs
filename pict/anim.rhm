#lang rhombus/static/and_meta

import:
  pict:
    expose:
      Pict

export:
  AnimPict
  sequential
  concurrent
  together
  above
  beside
  overlay

annot.macro 'Concurrency':
  annot_meta.pack_predicate('is_concurrent', '()')
fun is_concurrent(v):
  match v
  | #'early || #'middle || #'stretch || #'late: #true
  | ~else: #false

annot.macro 'Sequencing':
  annot_meta.pack_predicate('is_sequencing', '()')
fun is_sequencing(v):
  match v
  | #'append || #'squash: #true
  | ~else: #false

annot.macro 'Order': '(Concurrency || Sequencing)'

fun freshen(p :~ Pict): p.inset(0)

class AnimPict(private get_pict,
               epoch_durations :~ List.of(Real),
               start_epoch :~ Int,
               before :~ Pict,
               after :~ Pict):
  internal _AnimPict

  property epochs:
    math.max(0, epoch_durations.length() - start_epoch)

  property width: before.width
  property height: before.height
  property ascent: before.ascent
  property descent: before.descent

  property min_width: math.min(before.width, after.width)
  property min_height: math.min(before.height, after.height)
  property min_ascent: math.min(before.ascent, after.ascent)
  property min_descent: math.min(before.descent, after.descent)

  property max_width: math.max(before.width, after.width)
  property max_height: math.max(before.height, after.height)
  property max_ascent: math.max(before.ascent, after.ascent)
  property max_descent: math.max(before.descent, after.descent)

  constructor
  | (p :: Pict):
      super(fun (epoch, n):
              p,
            [0],
            0,
            p, p)
  | (proc :: Function.of_arity(1),
     ~duration: duration :: PosReal):
      let before :: Pict = proc(0)
      let after :: Pict = proc(1)
      super(fun (epoch, n):
              cond
              | epoch < 0: before
              | epoch >= 1 || n >= 1: after
              | n <= 0: before
              | ~else: proc(n),
            [duration],
            0,
            before,
            after)
  
  method pict(epoch :: Int, n :: Real.in(0, 1)) :~ Pict:
    get_pict(epoch, n)

  method
  | inset(amt :: Real) :~ AnimPict:
      inset(amt, amt, amt, amt)
  | inset(horiz :: Real, vert :: Real) :~ AnimPict:
      inset(horiz, vert, horiz, vert)
  | inset(left :: Real, top :: Real, right :: Real, bottom :: Real) :~ AnimPict:
      _AnimPict(fun (epoch, n):
                  let p :~ Pict = get_pict(epoch, n)
                  p.inset(left, top, right, bottom),
                epoch_durations, start_epoch,
                before.inset(left, top, right, bottom),
                after.inset(left, top, right, bottom))

  method timeclip(~keep: keep :: maybe(matching(#'before || #'after)) = #false) :~ AnimPict:
    _AnimPict(fun (epoch, n):
                let p :~ Pict = get_pict(epoch, n)
                cond
                | (epoch < 0) && keep != #'before:
                    p.ghost()
                | (epoch >= epochs) && keep != #'after:
                    p.ghost()
                | ~else:
                    p,
              epoch_durations, start_epoch,
              freshen(before), freshen(after))

fun merge_epochs([p :~ AnimPict, ...]):
  let min_epoch = math.min(p.start_epoch, ...)
  let max_epoch = math.max(math.max(0, (p.epoch_durations.length() + p.start_epoch) - 1), ...)
  let num_epochs = max_epoch + 1 - min_epoch
  let all_epochs:
    for List (i: min_epoch .. min_epoch + num_epochs):
      fun get(p :~ AnimPict):
        if i < p.start_epoch || i >= p.start_epoch + p.epoch_durations.length()
        | 0
        | p.epoch_durations[i-p.start_epoch]
      math.max(get(p), ...)
  values (min_epoch, max_epoch, num_epochs, all_epochs)

fun sequential(ps :: List.of(AnimPict),
               ~mode: mode :: Sequencing = #'append) :~ List.of(AnimPict):
  fun later(p :~ AnimPict, dt):
    if dt == 0
    | p
    | let _AnimPict(get, epochs, start_epoch, before, after) = p
      _AnimPict(fun (epoch, n): get(epoch - dt, n),
                epochs,
                start_epoch + dt,
                freshen(before), freshen(after))
  fun refocus(p :~ AnimPict, at_epoch, total, used):
    let index = at_epoch - p.start_epoch
    cond
    | index < 0 || index >= p.epoch_durations.length():
        p
    | total == p.epoch_durations[index]:
        p
    | ~else:
        let orig = p.epoch_durations[index]
        let ratio = orig / total
        let begin_ratio = used / total
        let _AnimPict(get, epochs, start_epoch, before, after) = p
        _AnimPict(fun (epoch, n):
                    cond
                    | epoch != at_epoch: get(epoch, n)
                    | n < begin_ratio: get(epoch - 1, 1)
                    | n >= begin_ratio + ratio: get(epoch, 1)
                    | ~else: get(epoch, (n - begin_ratio) / ratio),
                  epochs.delete(index).insert(index, total),
                  start_epoch,
                  before, after)
  match mode
  | #'append:
      let (accum, t):
        for values(accum :~ List = [],
                   dt = 0):
          each p: ps
          values(accum.add(later(p, dt)),
                 dt + math.max(0, p.epochs))
      accum
  | #'squash:
      let durations = MutableMap{}
      fun bump_durations(p :~ AnimPict, offset, durations :~ MutableMap):
        let start_index = -p.start_epoch
        let end_index = (p.epochs - p.start_epoch) - 1
        fun bump(index, offset):
          when index >= 0 && index < p.epoch_durations.length()
          | durations[offset] := durations.get(offset, 0) + p.epoch_durations[index]
        bump(start_index, offset)
        when start_index != end_index
        | bump(end_index, offset + p.epochs - 1)
        offset + math.max(0, p.epochs - 1)        
      for values(offset = 0) (p: ps):
        bump_durations(p, offset, durations)
      let used_durations = MutableMap{}
      let (accum, t):
        for values(accum :~ List = [], offset = 0):          
          each p: ps
          let start_total = durations.get(offset, 0)
          let start_used = used_durations.get(offset, 0)
          let new_p:
            let new_p = refocus(p, 0, start_total, start_used)
            if p.epochs <= 1
            | new_p
            | let end = offset + p.epochs - 1
              let end_total = durations.get(end, 0)
              let end_used = used_durations.get(end, 0)
              refocus(new_p, p.epochs - 1, end_total, end_used)          
          let new_offset = bump_durations(p, offset, used_durations)
          values(accum.add(later(new_p, offset)),
                 new_offset)
      accum

fun concurrent(ps :: List.of(AnimPict),
               ~align: align :: Concurrency = #'middle) :~ List.of(AnimPict):
  match ps
  | []: []
  | [p :~ AnimPict, ...]:
      let (min_epoch, max_epoch, num_epochs, all_epochs :~ List):
        merge_epochs([p, ...])
      for List (p: ps):        
        let _AnimPict(get, epochs, start_epoch, before, after) = p
        let num_epochs = epochs.length()
        _AnimPict(fun (epoch, n):
                    let e = epoch - start_epoch
                    get(epoch,                        
                        if epoch < 0 || epoch >= num_epochs
                        | n
                        | let duration = all_epochs[epoch - min_epoch]
                          if duration .= 0
                          | n
                          | let ratio = epochs[e] / duration
                            match align
                            | #'early: (if n < ratio | n / ratio | 1)
                            | #'late: (if n < 1 - ratio | 0 | (n - ratio) / ratio)
                            | #'middle: cond
                                        | n < (1 - ratio) / 2: 0
                                        | n >= 1 - ((1 - ratio) / 2): 1
                                        | ~else: (n - ((1 - ratio) / 2)) / ratio
                            | #'stretch: if ratio .= 0
                                         | 1
                                         | n / ratio),
                  for List (i: 0..epochs.length()):
                    all_epochs[start_epoch - min_epoch],
                  start_epoch,
                  freshen(before), freshen(after))

fun together(~order: order :: Order = #'middle,
             [p, ...]) :~ List.of(AnimPict):
  match order
  | #'append || #'squash: sequential(~mode: order, [p, ...])
  | ~else: concurrent(~align: order, [p, ...])

fun combine(~order: order,
            ps,
            stack_picts) :~ AnimPict:
  let [p :~ AnimPict, ...] = together(~order: order, ps)
  let (min_epoch, max_epoch, num_epochs, all_epochs):
    merge_epochs([p, ...])
  _AnimPict(fun (epoch, n):
              stack_picts([p.pict(epoch, n), ...]),
            all_epochs,
            min_epoch,
            stack_picts([_AnimPict.before(p), ...]),
            stack_picts([_AnimPict.after(p), ...]))

fun above(~sep: sep = 0,
          ~align: align :: pict.HorizontalAlignment = #'center,
          ~order: order :: Order = #'middle,
          p :~ AnimPict,
          ...) :~ AnimPict:
  fun stack_picts(ps):
    pict.above(~sep: sep,
               ~align: align,
               & ps)
  combine(~order: order,
          [p, ...],
          stack_picts) 

fun beside(~sep: sep = 0,
           ~align: align :: pict.VerticalAlignment = #'center,
           ~order: order :: Order = #'middle,
           p :~ AnimPict,
           ...) :~ AnimPict:
  fun stack_picts(ps):
    pict.beside(~sep: sep,
                ~align: align,
                & ps)
  combine(~order: order,
          [p, ...],
          stack_picts)

fun overlay(~halign: halign :: pict.HorizontalAlignment = #'center,
            ~valign: valign :: pict.VerticalAlignment = #'center,
            ~order: order :: Order = #'middle,
            p :~ AnimPict,
            ...) :~ AnimPict:
  fun stack_picts(ps):
    pict.overlay(~halign: halign,
                 ~valign: valign,
                 & ps)
  combine(~order: order,
          [p, ...],
          stack_picts)
